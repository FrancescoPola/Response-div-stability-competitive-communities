---
title: "Additional analysis for: The balance of nature: Critical Role of Species Environmental Responses for Stability"
author: "Til Hämmig, Francesco Polazzo, Owen L. Petchey, Frank Pennekamp"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    code_folding: hide
    keep_md: no
    fig_caption: false  
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
rm(list=ls())
library("ggplot2")
library("tidyverse")
library("gridExtra")
#library(rEDM)
library("parallel")
library("pracma")
library("purrr")
library("signal")
library("ggfortify")
library("data.table")
library("patchwork")
library("codyn")
library("ggrepel")
library("lme4")
library("lmerTest")
library("MuMIn")
library("RColorBrewer")
library("broom")
library("relaimpo")
library("lavaanPlot")
library(ggbeeswarm)
library(performance)
library(broom)
library(kableExtra)
library(gt)
library(lavaan)


#devtools::install_github("canankarakoc/r_package_EDMhelper/EDMhelper")

```

```{r include = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      include = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      cache = FALSE)
```


# Introduction

This document provides a reproducible record of the analyses we performed to check the robustness of our results. Specifically, it focuses on the robustness of the main findings when restricting the analysis to the final 20 days of the experiment, thereby excluding the initial transient dynamics.

The main article investigates how the distribution of species' fundamental responses to environmental change—quantified using our novel metric of fundamental imbalance—influences the temporal stability of community biomass. Here, we reproduce the core analyses using only data from the last 20 days, to assess whether the relationships observed in the full dataset remain consistent when focusing on periods that better reflect equilibrium-like conditions.

We show that the key results—particularly the effects of imbalance, nutrients, temperature, and species richness on temporal stability—are robust even when early, potentially transient dynamics are removed. This strengthens the generality of the conclusions presented in the main text.

All results in this document are generated using an R Markdown file and are fully reproducible from the processed experimental dataset.



# Load datasets, Data wrangling and Imbalance calculation

# Biomass

The first 2/3 weeks of the experiment show a strong increase in community biomass, which is followed by a decrease in the ~30 days of the experiment. It looks like there were some transient dynamics in the beginning of the experiment, which is followed by a stable phase. Since we are interested in the stability of the stable phase, we exclude the transient dynamics from the analysis. We do this by removing the first 40 days of the experiment.

```{r  warning=FALSE, results='hide'}

divergence_df <- read_csv("Data/divergence_df.csv")
load("Data/dens_biomass_poly.RData")

dd_all_pred<-read.csv("Data/morph_dd_pred.csv")
dd_all_pred_nonoise<-read.csv("Data/morph_dd_pred_nonoise.csv")

load("Data/ciliate_traits.Rdata")

df_slopes <- read_csv("Data/df_slopes_cor.csv")

# needs to have id_new variable
ciliate_traits <- ciliate_traits %>%
  dplyr::mutate(
    # Remove dots from the date
    cleaned_date = gsub("\\.", "", date),
    # Extract the part of id after the underscore
    id_suffix = sub(".*_(.*)", "\\1", id),
    # Combine cleaned_date, id_suffix, and species_initial into a new variable
    id_new = paste0(cleaned_date, id_suffix, composition)
  ) %>%
  # Optionally, remove the intermediate columns to clean up
  dplyr::select(-cleaned_date, -id_suffix,-new_id)

uniqueN(ciliate_traits$id_new)==nrow(ciliate_traits) # all unique  ;)

id_dd<-full_join(dd_all_pred,dplyr::select(ciliate_traits,id_new,biomass),join_by("id_new"))


## add day variable

#create a day variable from the date variable

id_dd<-dplyr::mutate(id_dd,date=as.Date(date,format = "%d.%m.%y"))

earliest_date<-min(id_dd$date)
days_since_earliest<-as.numeric(id_dd$date-earliest_date)+1
id_dd<-id_dd%>%dplyr::mutate(day=days_since_earliest)

#create a summarised df on microcosm level with each species seperate
# Make sure, that we have n_frames and not N_frames
names(id_dd)[names(id_dd) == "N_frames"] <- "n_frames"

#extrapolation_factor <- 9.301902  # for 16 x magnification 
extrapolation_factor <- 9.828125  # for 25 x magnification 
video_biomass_species <- c( "C", "P", "S","D","L","T")

biomasses <- id_dd %>%
  dplyr::group_by( day,temperature,nutrients,sample_ID,composition,predict_spec) %>% # group  by xxx
  dplyr::summarize(
    biomass = sum(biomass * n_frames, na.rm = TRUE) / (1 * 125) # if not 3 videos corrections is done below with dens_factor
  ) %>%
  dplyr::mutate(
    biomass = biomass * extrapolation_factor,
    )

biomasses<-biomasses%>%dplyr::mutate(biomass=biomass*1000)

dd_ts_id<-biomasses

#fill up missing dates with biomass<-0

fill_dd<-expand.grid(sample_ID=unique(dd_ts_id$sample_ID),day=unique(dd_ts_id$day),predict_spec=unique(dd_ts_id$predict_spec))
complete_ts1<-full_join(fill_dd,dd_ts_id,join_by(sample_ID,day,predict_spec))


complete_ts <- complete_ts1 %>% dplyr::filter(day >= 40)
complete_ts$biomass[is.na(complete_ts$biomass)]<-0
complete_ts<-complete_ts%>%dplyr::mutate(composition=sub("_.*", "", sample_ID))
complete_ts<-complete_ts %>%
  dplyr::mutate(temperature = sapply(strsplit(as.character(sample_ID), "_"), function(x) paste(x[3], x[4], sep = "-")))
complete_ts<- dplyr::mutate(complete_ts,nutrients = gsub(".*Nut(.*?)_.*", "\\1", sample_ID))

# Now remove wrong combinations of composition and predict_spec / predict_spec

complete_ts<- complete_ts %>%
  rowwise() %>%
  dplyr::filter(predict_spec %in% unlist(strsplit(composition, ""))) %>%
  ungroup()  
complete_ts<-dplyr::mutate(complete_ts,temperature=as.character(temperature),
                    nutrients=as.character(nutrients),
                    richness=nchar(composition))


complete_ts<-complete_ts%>%group_by(sample_ID,composition,day)%>%dplyr::mutate(tot_biomass=sum(biomass))
complete_ts<-complete_ts%>%dplyr::mutate(biom_contribution=biomass/tot_biomass)

df_biomass_mod <- complete_ts

complete_ts<-complete_ts%>%dplyr::mutate(temperature=paste0(temperature," °C"),
                                      nutrients=paste0(nutrients," g/L"))


# introduce slopes of 
names(df_slopes)[names(df_slopes)=="species_initial"]<-"predict_spec"

slope_ts<-full_join(dplyr::select(df_slopes,nutrients,predict_spec,temperature,slope),complete_ts)
slope_ts<-slope_ts%>%dplyr::mutate(w_slope=biom_contribution*slope,
                            sign=sign(slope))

slope_ts<-slope_ts%>%group_by(sample_ID,temperature,nutrients,richness,composition,day,tot_biomass)%>%dplyr::summarize(
  sum_w_slopes=abs(sum(w_slope)),
                   mean_abs_slope=mean(abs(slope)),
  sum_abs_slope=sum(abs(slope)),
  abs_sum_slope=abs(sum(slope)),
  symmetry=abs(sum(sign)))


slope_ts<-slope_ts%>%dplyr::mutate(richness=as.factor(richness))


##create new variable where it checks, where the last observation =0 is; with complete_ts
aggr_ts <- slope_ts %>%
  group_by( sample_ID) %>%
  arrange(day) %>%
  mutate(
    # Create a flag for non-zero tot_biomass
    non_zero_biomass = tot_biomass != 0,
    # Find the last non-zero day
    last_non_zero_day = ifelse(any(non_zero_biomass), max(day[non_zero_biomass], na.rm = TRUE), NA),
    # Find the first zero day after the last non-zero day
    first_zero_day = ifelse(
      !is.na(last_non_zero_day),
      min(day[!non_zero_biomass & day > last_non_zero_day], na.rm = TRUE),
      NA
    ),
    # Flag for days after the first zero day
    is_after_first_zero_day = ifelse(!is.na(first_zero_day), day > first_zero_day, FALSE)
  ) %>%
  ungroup()

aggr_ts<-aggr_ts%>%mutate(rep_var=sub("_[^_]+$", "", sample_ID))

### cut of time series when species extinct
aggr_ts_no_ext<-aggr_ts%>%dplyr::filter(is_after_first_zero_day==F)

biomass_ts<-aggr_ts_no_ext%>%dplyr::group_by(day,temperature,nutrients,richness)%>%summarize(tot_biom=mean(tot_biomass),se_tot_biom=sd(tot_biomass)/sqrt(as.numeric(length(tot_biomass))))


```


# Plot biomass last 20 days

```{r plot_biomass_20, fig.align="center", fig.height=8, fig.width=15}

plot_biomass<-ggplot(data=biomass_ts)+
  geom_ribbon(aes(x=day,y=tot_biom,fill=richness,color=richness,ymin=tot_biom-se_tot_biom,ymax=tot_biom+se_tot_biom),show.legend=F,alpha=0.5)+
  geom_line(method="loess",se=F,aes(x=day,y=tot_biom,color=richness),size=0.8)+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
   scale_fill_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  theme_classic()+
  #geom_text_repel( data=biomass_ts%>%dplyr::filter(day==58,tot_biom!=0),aes(x=day,y=tot_biom,group=composition,label = composition), size = 4,max.overlaps = 20) +
  facet_wrap(temperature~nutrients,scale="free_y")+
  theme(axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 12))+
  ylab(expression("Community biomass [mg ml"^-1 * "]"))
  
plot_biomass
```

 **Figure 1** : Community total biomass during the experiment in different environmental treatments. Different color represent richness levels. The first 40 days of the experiment are excluded from the analysis, since they show transient dynamics.




# Main Results 

We now look at the main results of the experiment. We are going to look first at the effect of richness, temperature and nutrients on community temporal stability. Then, we are going to look at the relationship between divergence (original response diversity metric) and temporal stability. Finally, we are going to look at the relationship between imbalance and temporal stability.

In the whole analysis, we calculated the temporal stability of total community biomass as the inverse of the coefficient of variation (ICV) (i.e. $\frac{\sigma}{\mu}$). 
```{r results='hide', echo=FALSE, warning=FALSE}
## discard all the rows that are part of time stretches where entire microcosms has (seemingly) gone extinct
#%>%dplyr::filter(is_after_first_zero_day==FALSE)

complete_aggr<- aggr_ts_no_ext %>%
  group_by(composition,nutrients,temperature,sample_ID) %>%
  reframe(
  avg_w_sumslopes=mean(sum_w_slopes,na.rm = T),
  abs_sum_slope=mean(abs_sum_slope),
  magnitude=mean(mean_abs_slope),
  symmetry=mean(symmetry),
  sum_abs_slope=mean(sum_abs_slope),
  CV=sd(tot_biomass)/mean(tot_biomass),
  mean_biomass=mean(tot_biomass))

complete_aggr<- full_join(divergence_df,complete_aggr,by=join_by(composition,nutrients,temperature)) %>%
  mutate(richness=as.factor(richness))



```

### Effect of T, N and R
```{r boxplots_TNR, results='hide', echo=FALSE, warning=FALSE, fig.align="center", fig.height=8, fig.width=20}
#### effects of temperature; nutrient and richness, now with complete time series

# Boxplot and jitter for temperature
plot_T_complete <- ggplot(data = complete_aggr %>% dplyr::filter(CV != "NaN"), aes(x = temperature, y = log10(1 / CV))) +
  geom_boxplot(outlier.shape = NA, aes(group = temperature, color = temperature), alpha = 0.8) +
  geom_jitter(aes(color = as.factor(temperature)), width = 0.2, size = 4, alpha = 0.65) +
  theme_classic(base_size = 25) +
  xlab("Temperature regime") +
  labs(color = "Temperature regime", tag = "(b)") +
  theme(legend.position = "none", axis.title.y = element_blank()) +
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8) 

# Boxplot and jitter for nutrients
plot_N_complete <- ggplot(data = complete_aggr %>% dplyr::filter(CV != "NaN"), aes(x = nutrients, y = log10(1 / CV))) +
  geom_boxplot(outlier.shape = NA, aes(group = nutrients, color = nutrients), alpha = 0.8) +
  geom_jitter(aes(color = as.factor(nutrients)), width = 0.2, size = 4, alpha = 0.65) +
  theme_classic(base_size = 25) +
  xlab("Nutrients") +
  theme(legend.position = "none", axis.title.y = element_blank()) +
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8) +
  labs(tag = "(c)")

# Boxplot and jitter for richness
plot_R_complete <- ggplot(data = complete_aggr %>% dplyr::filter(CV != "NaN"), aes(x = richness, y = log10(1 / CV))) +
  geom_boxplot(outlier.shape = NA, aes(group = richness, colour = richness), alpha = 0.8) +
  geom_jitter(aes(color = as.factor(richness)), width = 0.2, size = 4, alpha = 0.65) +
  theme_classic(base_size = 25) +
  xlab("Richness") +
  ylab("Temporal stability\nlog(mean/s.d.)") +
  theme(legend.position = "none") +
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8) +
  labs(tag = "(a)") 

# Combine plots in a single row
combined_plot <- plot_R_complete | plot_T_complete | plot_N_complete 

# Add global label for the y-axis
combined_plot <-combined_plot 

# Display the final combined plot
print(combined_plot)

#ggsave("figures_ms/fig.1.png", plot = combined_plot, width = 20, height = 8, dpi = 600)

```


**Figure 2**: Effects of richness (a), temperature (b), and nutrients (c) on community total biomass temporal stability.


We can see that richness and temperature do not have a clear effect on community temporal stability, while stability was higher at higher nutrient concentration.




# Effect RD

We are now going to look at how imbalance affected temporal stability of total community biomass. We are going to look at the relationship between fundamental imbalance (so based only on species response surfaces measured in monoculture), an realised imbalance (measured accounting for species contribution to balance).

This is fundamentally testing our most important hypothesis.


```{r results='hide', echo=FALSE, warning=FALSE, message=FALSE}

complete_aggr <- complete_aggr %>% mutate(stability = 1/CV) %>% 
  dplyr::rename(balance_f = abs_sum_slope,
                balance_r = avg_w_sumslopes)



# summary(lm_full)
# anova(lm_full)
```

```{r effect_RD, results='hide', echo=FALSE, warning=FALSE, fig.align="center", fig.height=10, fig.width=20}

balance_dd<- complete_aggr %>%
  dplyr::select(balance_f,richness,CV, temperature) %>%
  cbind(type="fundamental") %>%
  mutate(balance_f=balance_f/as.numeric(richness))

names(balance_dd)[names(balance_dd)=="balance_f"]<-"balance"

weighted_balance_dd<-complete_aggr%>%dplyr::select(balance_r,richness,CV, temperature)%>%
  cbind(type="realised")
names(weighted_balance_dd)[names(weighted_balance_dd)=="balance_r"]<-"balance"

main_r_dd<-rbind(balance_dd,weighted_balance_dd)
any(main_r_dd$CV <= 0, na.rm = TRUE)
main_r_dd <- main_r_dd %>%
  dplyr::filter(is.finite(log10(1/CV)), CV > 0)

common_ylims <- range(log10(1 / complete_aggr$CV), na.rm = TRUE)

# Then add to each plot:


plot_main <- main_r_dd %>%
  ggplot(aes(x = (log10(balance)), y = log10(1/CV), color = type)) +
  geom_point(aes(x = log10(balance), y = log10(1/CV)), size = 5, alpha = 0.65) +
  geom_smooth(method = "lm", aes(x = log10(balance), y = log10(1/CV)), linewidth = 3, show.legend=F) +
  theme_classic() +
  scale_color_viridis_d(option = "inferno", begin = 0.3, end = 0.6) +
  ylab("Temporal stability\nlog(mean/s.d.)")+
  xlab("log10(Imbalance)") +
 theme(
    axis.title.x = element_text(size = 25),
    axis.title.y = element_text(size = 25),
    axis.text = element_text(size = 20),                      # Axis text size             # Facet label text size
    legend.title = element_text(size = 25),                   # Legend title size
    legend.text = element_text(size = 25),                     # Legend text size
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 25)) +
  labs(color = "Imbalance") +  
  facet_wrap(~richness, labeller = as_labeller(function(x) paste0("richness = ", x))) + 
  coord_cartesian(ylim = common_ylims)

plot_main

#ggsave("figures_ms/fig.2.png", plot = plot_main, width = 20, height = 10, dpi = 600)
```

**Figure 7**: Effects of fundamental and realised imbalance on total community biomass temporal stability.


We can see that imbalance is always negatively related to temporal stability, which means that balance in species responses promotes stability across richness levels. Interestingly, we see that there is little difference between fundamental and realised imbalance. 


But is the difference between fundamental and realised imbalance significant? We can test this using a linear model with both fundamental and realised imbalance as predictors of stability, and one with only fundamental imbalance as predictor of stability, and compare whether the models are significantly different.

## Imbalance: realised vs fundamental
```{r include=TRUE, echo=TRUE}
# compare if the slope of fundamental and realised balance is significantly different for each richness level
# Fit the linear model with interaction
complete_aggr_2<- complete_aggr %>%
  # Remove the units from the 'nutrients' and 'temperature' columns
  mutate(
    nutrients = as.numeric(gsub(" g/L", "", nutrients)),  # Convert nutrients to numeric
    temperature = gsub(" °C", "", temperature)            # Remove the unit but keep as character
  ) %>%
  # Convert temperature ranges to numeric codes using case_when
  mutate(
    temperature = case_when(
      temperature == "18-21" ~ 1,
      temperature == "22-25" ~ 2,
      temperature == "25-28" ~ 3,
      TRUE ~ NA_real_         # Handle unexpected values with NA
    )
  )


# Fit the linear model with interaction
lm_full_int1<-lm(data=complete_aggr_2,log10(stability)~log10(balance_f)+scale(nutrients)*scale(temperature)+richness)
lm_full_int2<-lm(data=complete_aggr_2,log10(stability)~log10(balance_f)+ log10(balance_r)+scale(nutrients)*scale(temperature)+richness)

```

**Table 7**: Anova table of the model with only realised balance vs one with both realised and fundamental balance as predictors of stability.
```{r include = TRUE, echo=TRUE}
anova5 <- anova(lm_full_int1, lm_full_int2, test = "Chisq")


anova_tidy5 <- broom::tidy(anova5)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy5 %>%
  gt() %>%
  cols_label(
    term = "Term",
    df.residual = "DF",
    rss = "RSS",
    sumsq = "sumsq",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(600),            # Adjust table width (e.g., 400px)
    table.font.size = px(12),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )



```


A model with both fundamental and realised imbalance as predictors improved very little the variance explained by the model. The two models are not significantly different, suggesting that fundamental imbalance captures well the effect of imbalance on stability, and adding the species contribution to total biomass (realised imbalnce) does not improved the model.

We now compare also the AIC of the two models
```{r include=TRUE, echo=TRUE}
AIC(lm_full_int1, lm_full_int2)
```

The AIC of the model with only fundamental imbalance is lower than the AIC of the model with both fundamental and realised imbalance, suggesting that the model with only fundamental imbalance is a better model. However, the difference is very small. 




# Linear models

## Dependence of Imbalance on Temperature

Since imbalance depends on the slopes of species' responses, and the slopes of species responses between two environmental conditions depend on the shape of species responses and the position of the optimum of the species response curve, we may expect that imbalance depends on temperature. For example, when the environment (i.e. temperature) fluctuates at higher mean temperatures, the species responses may be more similar (i.e. all species have the same sign of response), leading to less symmetrical response distributions, and thus higher imbalance.

We look now at how imbalance changes with temperature, in all possible combinations of species responses for each richness level and each environmental condition. We calculate the sum of slopes of all possible combinations of species responses, and then calculate the imbalance for each combination. We then plot the relationship between imbalance and temperature for each combination of species responses.


```{r}
# Function to calculate combinations and their sum of slopes
calculate_compositions <- function(data) {
  # Generate combinations for n = 2, n = 3, n = 4
  combinations <- lapply(2:4, function(n) combn(data$predict_spec, n, simplify = FALSE))
  combinations <- unlist(combinations, recursive = FALSE)
  # Create a dataframe with combinations and their summed slopes
  result <- data.frame(
    composition = sapply(combinations, paste, collapse = ""),
    sum_slopes = sapply(combinations, function(comb) {
      sum(data$slope[data$predict_spec %in% comb])
    }),
    magnitude=sapply(combinations, function(comb) {
      sum(abs(data$slope[data$predict_spec %in% comb]))
    })
  )
  return(result)
}
 
 
# Apply the function for each group of `nutrients` and `temperature`
all_combi_df <- df_slopes %>%
  group_by(nutrients, temperature) %>%
  group_split() %>%
  lapply(function(group_data) {
    compositions <- calculate_compositions(group_data)
    # Add nutrients and temperature columns to each result
    compositions$nutrients <- unique(group_data$nutrients)
    compositions$temperature <- unique(group_data$temperature)
    return(compositions)
  }) %>%
  bind_rows()
 
all_combi_df<-all_combi_df%>%mutate(balance=abs(sum_slopes),
                              richness=as.factor(nchar(composition)))
 
all_combi_df<-all_combi_df%>%mutate(is_selected=all_combi_df$balance%in%complete_aggr$balance_f)
 
test_representative<-t.test(log10(dplyr::filter(all_combi_df,is_selected==F)$balance),log10(dplyr::filter(all_combi_df,is_selected==T)$balance),var.equal = F)
 
 
lm_representative<-lm(data=all_combi_df,log10(balance)~temperature*is_selected)
#check_model(lm_representative)
```

```{r effect_T, results='hide', echo=FALSE, warning=FALSE, fig.align="center", fig.height=10, fig.width=20}
plot_all_combi<-ggplot(data=all_combi_df)+theme_bw(base_size = 25)+
  geom_quasirandom(data= all_combi_df,aes(y=log10(balance), x=temperature, group=temperature, colour=as.factor(temperature)),
                                  dodge.width=2, size= 6) +
 
  xlab("Temperature regime")+
  ylab("log10(balance)")+
  labs(color="Temperature regime", tag = "(a)")+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  facet_wrap(~is_selected,labeller = as_labeller(c("FALSE"="Not Selected","TRUE"="Selected")))+
  theme(legend.position = "none", strip.text = element_text(size = 25),
         strip.background = element_rect(fill = "grey80", color = NA))
 
 
plot_all_combi
```


**Figure 8**: Relationship between imbalance and temperature for all possible combinations of species responses. The points represent the imbalance of each combination of species responses The points are colored by temperature regime, and the facets represent whether the combination of species responses was selected for the experiment.


We can see that imbalance increases with temperature, and that the relationship is the same in selected vs non selected community compositions. This suggests that imbalance is intrinsically dependent on temperatures, and that the species responses are more similar when the environment fluctuates at higher temperatures.
Inevitably, this will affect the stability of the community, as we have seen in the previous analysis. Yet, it also means that the effect of imbalance on stability is not independent of temperature, or more generally, of the environmental conditions. Indeed, temperature and nutrients have been used to estimate species' responses, and thus imbalance inherently depends on the environment.

Let's look at the variance explained by imbalance and the environment on stability.
```{r Rsquared,  fig.align="center", fig.height=6, fig.width=12}
lm_balance_env<-lm(data=complete_aggr_2,log10(stability)~log10(balance_f)+scale(nutrients)*scale(temperature))
lm_balance<-lm(data=complete_aggr_2,log10(stability)~log10(balance_f))
lm_env<-lm(data=complete_aggr_2,log10(stability)~scale(nutrients)*scale(temperature))
 
 
sum_lm_balance<-summary(lm_balance)
sum_lm_env<-summary(lm_env)
sum_lm_balance_env<-summary(lm_balance_env)
 
  
R2_env_bal<-data.frame(R2=c(sum_lm_balance$r.squared,sum_lm_env$r.squared,sum_lm_balance_env$r.squared,
                            sum_lm_balance_env$r.squared-sum_lm_env$r.squared,
                            sum_lm_balance_env$r.squared-sum_lm_balance$r.squared,
                            0),
                       model=factor(c("log10(balance)","nut * temp","log10(balance) + nut * temp","log10(balance)","nut * temp","log10(balance) + nut * temp")),
                       type=c("total","total","total","unique","unique","unique"))
 
 
plot_R2_bal_env<-ggplot(data=R2_env_bal%>%dplyr::filter(type=="total"),aes(y=R2,x=factor(model,levels=c("log10(balance)","nut * temp","log10(balance) + nut * temp")),fill=type))+
  geom_col(width=0.7)+
  geom_col(data=R2_env_bal%>%dplyr::filter(type=="unique"),width=0.7)+
  theme_classic()+
   theme(axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18),
         axis.text = element_text(size = 15),      
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 18),plot.tag = element_text(size = 18),
     legend.text = element_text(size = 15), # Adjust legend text size
    legend.title = element_blank() ) +
   xlab("Model terms") +
  ylab(expression(R^2))+
  scale_fill_manual(values = c("total" = "grey80", "unique" = "grey20"))+labs(tag="(a)")
plot_R2_bal_env
```

**Figure 8**: Variance explained by imbalance and the environment on stability. The total variance explained by imbalance and the environment is shown in grey, and the unique variance explained by imbalance and the environment is shown in light grey.


95% of the variance explained by balance is shared with nutrients and temperature, which is not suprising considering how imbalance is calculated. However, there is additional variance explained by the environment that is not shared with balance. This suggests that the environment has an independent effect on stability, which is not mediated by imbalance.
This may be related to the fact that imbalance was calculated using monoculture data collected at constant temperature, whereas in the community experiment, temperature was fluctuating, and species were interacting.



# Model only looking at imbalance and richness, environmental conditions as random effects

We first investigate the effect of **imbalance** on stability while accounting for different environmental contexts. We fit a linear mixed-effects model including temperature, nutrient level, and composition as random factors to account for the different environmental contexts in which the imbalance was measured. This allows us to assess the effect of imbalance on stability while controlling for the influence of temperature and nutrient levels.

```{r include=TRUE, echo=TRUE}

model_rev3 <-lmer(log10(stability) ~ log10(balance_f) + richness + 
       (1 + temperature + nutrients || composition),
     data = complete_aggr_2,
  REML = FALSE
)

```

```{r model_check_int, fig.cap='model check 1.', fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
# check model's assumptions
check_model(model_rev3)
```
**Figure 9**: Model check for the linear mixed-effects model with balance, richness as fixed effect. The model fits reasonably well the data.


**Table 10**: Linear mixed-effects model results for the effects of balance, richness on community stability. Estimates are presented with 95% confidence intervals and p-values. 

```{r}
# Create a gtsummary table


tbl_summary <- gtsummary::tbl_regression(
  model_rev3,
  intercept = TRUE,
  label = list(`(Intercept)` = "Intercept")  # Only this works reliably here
  # Skip the log_balance renaming here if it doesn't take effect
) %>%
  gtsummary::modify_table_body(
    ~ .x %>%
      dplyr::mutate(
        t_value = ifelse(!is.na(estimate), round(statistic, 2), NA),
        std_error = NULL,
        label = dplyr::case_when(
          variable == "log10(balance_f)" ~ "log10(imbalance)",
          TRUE ~ label
        )
      )
  ) %>%
  gtsummary::modify_header(
    label = "**Predictor**",
    estimate = "**Estimate**",
    conf.int = "**95% CI**",
    t_value = "**t-value**",
    p.value = "**p-value**"
  ) %>%
  gtsummary::modify_footnote(everything() ~ NA) %>%
  gtsummary::bold_labels() %>%
  gtsummary::as_gt() %>%
  gt::tab_header(title = "Linear Regression Results") %>%
  gt::cols_move(p.value, after = last_col()) %>%
  gt::tab_style(
    style = gt::cell_text(weight = "bold"),
    locations = gt::cells_body(
      columns = p.value,
      rows = p.value < 0.05
    )
  )


tbl_summary

```

**Table 11**: ANOVA table of the linear mixed-effects model with balance and richness as predictors of stability.

```{r}
anova_F <- car::Anova(model_rev3, type = "III")
# Convert to tidy format
anova_tidyF <- broom::tidy(anova_F)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidyF %>%
  mutate(
    term = dplyr::case_when(
      term == "log10(balance_f)" ~ "log10(imbalance)",
      TRUE ~ term
    )
  ) %>%
  gt() %>%
  cols_label(
    term = "Term",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(600),
    table.font.size = px(20),
    data_row.padding = px(10)
  )

```

Using the model suggested by reviewer 3, we find that imbalance is a significant predictor of stability, and that the model explains a significant amount of variance in stability. Richness effect on stability remains very small. 


## Model presented in the main text - BUT with only the last 20 days of the experiment

To disentangle the shared variance between imbalance, temperature, and nutrients, we first removed the variance in temperature and nutrients that could be explained by imbalance. This can be done by regressing temperature and nutrients on imbalance and extracting the residuals, a method previously used to isolate independent effects among collinear predictors (e.g., [Dormann et al. 2013](https://nsojournals.onlinelibrary.wiley.com/doi/full/10.1111/j.1600-0587.2012.07348.x); [Graham 2003](https://esajournals.onlinelibrary.wiley.com/doi/full/10.1890/02-3114?casa_token=tjLz0BPcLf4AAAAA%3AYjunSb9xlIaHNsO0YLwGDjWzZswdTkVOWfcsBfIC3WjrA-n5B_94cOP2LFP5WIXMhunDwZOPFXCQqg)). The residual temperature and nutrient values thus represented variation independent of imbalance, allowing us to test their effects on stability without confounding influences of shared variance with imbalance. This approach enabled us to evaluate the relative importance of species richness and imbalance while accounting for environmental variability. By including residual temperature and nutrient values in the model, we ensured that our analysis focused on their independent contributions to stability.


## Control effect of environment on balance

```{r}
lm_temp_resid<-lm(data=complete_aggr_2, temperature ~ log10(balance_f))

lm_nut_resid<-lm(data=complete_aggr_2, nutrients ~ log10(balance_f))
 
resid_temp<-lm_temp_resid$residuals

resid_nut<-lm_nut_resid$residuals
 
complete_aggr_2<-complete_aggr_2%>%mutate(resid_temp=resid_temp,resid_nut=resid_nut)
 
```

Now, we can build a linear model with imbalance, richness, the residuals of temperature and nutrients and their interaction as predictors of stability. We also use composition as random effect to account for some compositions being used in more than one treatment combination. 

We also want to test whether the inclusion of random slopes for log10(balance_f) improves the model’s ability to explain variability in log10(stability) among compositions. We will compare the model with random slopes for log10(balance_f) to the model without random slopes for log10(balance_f) using a Likelihood Ratio Test.

```{r}


# Fit the mixed-effects model without random effects
model_no_random <- lmer(log10(stability) ~ log10(balance_f) +  richness + resid_temp * resid_nut+ 
                        (1 | composition), data = complete_aggr_2, REML = FALSE)




# Fit the mixed-effects model with random effects
model_with_random <- lmer(log10(stability) ~ log10(balance_f) + resid_temp*resid_nut+ richness + 
                          (1 + log10(balance_f) | composition), data = complete_aggr_2, REML = FALSE)


# Compare the models
anova(model_no_random, model_with_random)



```

A model with random slopes for log10(balance_f) is not better than one without. Thus, we will use the model without random slopes for log10(balance_f) for the rest of the analysis.

```{r model_check_int2, fig.cap='model check 1.', fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
# check model's assumptions
check_model(model_no_random)
```

**Figure 11**: Model check for the linear mixed-effects model with balance, richness, and the residuals of temperature and nutrients as predictors of stability. The model fits well the data.


**Table 13**: Linear mixed-effects model results for the effects of balance, richness, and the residuals of temperature and nutrients on community stability. Estimates are presented with 95% confidence intervals and p-values. 

```{r}
# Create a gtsummary table


tbl_summary <- gtsummary::tbl_regression(
  model_no_random,
  intercept = TRUE,
  label = list(`(Intercept)` = "Intercept")
) %>%
  gtsummary::modify_table_body(
    ~ .x %>%
      dplyr::mutate(
        t_value = ifelse(!is.na(estimate), round(statistic, 2), NA),
        std_error = NULL,
        label = dplyr::case_when(
          variable == "log10(balance_f)" ~ "log10(imbalance)",
          variable == "resid_temp" ~ "Residuals of temperature",
          variable == "resid_nut" ~ "Residuals of nutrients",
          variable == "resid_temp:resid_nut" ~ "interaction temperature * nutrients",
          TRUE ~ label
        )
      )
  ) %>%
  gtsummary::modify_header(
    label = "**Predictor**",
    estimate = "**Estimate**",
    conf.int = "**95% CI**",
    t_value = "**t-value**",
    p.value = "**p-value**"
  ) %>%
  gtsummary::modify_footnote(everything() ~ NA) %>%
  gtsummary::bold_labels() %>%
  gtsummary::as_gt() %>%
  gt::tab_header(title = "Linear Regression Results") %>%
  gt::cols_move(p.value, after = last_col()) %>%
  gt::tab_style(
    style = gt::cell_text(weight = "bold"),
    locations = gt::cells_body(
      columns = p.value,
      rows = p.value < 0.05
    )
  )


tbl_summary

```

Results do not fundamentally change, but there is not an interaction between temperature and nutrients anymore. If anything, the effect of imbalance is even large in the last 20 days of the experiment, and the effect of richness is even smaller.


**Table 14**: ANOVA table of the linear mixed-effects model with balance, richness, and the residuals of temperature and nutrients as predictors of stability.

```{r}
anova_F <- car::Anova(model_no_random, type = "III")
# Convert to tidy format
anova_tidyF <- broom::tidy(anova_F)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidyF <- broom::tidy(anova_F)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidyF %>%
  mutate(
    term = dplyr::case_when(
      term == "log10(balance_f)" ~ "log10(imbalance)",
      TRUE ~ term
    )
  ) %>%
  gt() %>%
  cols_label(
    term = "Term",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(600),
    table.font.size = px(20),
    data_row.padding = px(10)
  )

```





# Asynchrony
Response diversity (one of the stabilisng effects captured by imbalance) has been suggested as a mechanism that promotes temporal stability of community biomass by promoting species asynchrony.

We thus calculated the asynchrony index suggested by [Gross et al. 2014](https://www.journals.uchicago.edu/doi/epdf/10.1086/673915) to calculate the effect of asynchrony on temporal stability and to see how response diversity relate to asynchrony.
The index ranges between -1 and 1, with -1 indicating perfect asynchrony and 1 being perfectly synchronous, and 0 indicating random variation.




```{r echo=F, warning=FALSE, results='hide'}

#filter out completely extinct microcosms

 async_df<-complete_ts%>%dplyr::mutate(rep_var=sub("_[^_]+$", "", sample_ID))
### remove extinc
async_df<-async_df%>%
  group_by(predict_spec,sample_ID)%>%
arrange(day) %>%
  mutate(
    # Create a flag for non-zero tot_biomass
    non_zero_biomass = biomass != 0,
    # Find the last non-zero day
    last_non_zero_day = ifelse(any(non_zero_biomass), max(day[non_zero_biomass], na.rm = TRUE), NA),
    # Find the first zero day after the last non-zero day
    first_zero_day = ifelse(
      !is.na(last_non_zero_day),
      min(day[!non_zero_biomass & day > last_non_zero_day], na.rm = TRUE),
      NA
    ),
    # Flag for days after the first zero day
    is_after_first_zero_day = ifelse(!is.na(first_zero_day), day > first_zero_day, FALSE)
  ) %>%
  ungroup()
 
async_df<-async_df%>%dplyr::filter(is_after_first_zero_day==F)
 


safe_synchrony <- function(df) {
  # Step 1: Find species with variance > 0
  species_with_var <- df %>%
    group_by(predict_spec) %>%
    summarise(biomass_var = var(biomass, na.rm = TRUE), .groups = "drop") %>%
    dplyr::filter(biomass_var > 0)

  # Step 2: Keep only those species in the original df
  df <- df %>%
    semi_join(species_with_var, by = "predict_spec")

  # Step 3: Run synchrony only if we have enough species
  if (n_distinct(df$predict_spec) < 2) {
    return(tibble(synchrony_Gross = NA_real_))
  }

  tryCatch({
    s <- synchrony(
      df,
      time.var = "day",
      species.var = "predict_spec",
      abundance.var = "biomass",
      metric = "Gross"
    )

    if (is.numeric(s) && length(s) == 1) {
      return(tibble(synchrony_Gross = s))
    } else {
      return(tibble(synchrony_Gross = NA_real_))
    }
  }, error = function(e) {
    tibble(synchrony_Gross = NA_real_)
  })
}


 async_Gross <- async_df %>%
   group_by(composition, sample_ID) %>%
   group_modify(~safe_synchrony(.x)) %>%
   ungroup()


 async_Gross<-dplyr::mutate(async_Gross,synchrony_Gross=synchrony_Gross%>%unlist())


async_Loroeau <- async_df %>% group_by(composition,sample_ID) %>%
  do(synchrony_L = synchrony(., "day", "predict_spec",
                              "biomass", metric = "Loreau"))
async_Loroeau<-dplyr::mutate(async_Loroeau,synchrony_Loreau=synchrony_L%>%unlist())

async_aggr<-full_join(async_Gross,complete_aggr,join_by(sample_ID,composition))

async_aggr<-full_join(async_aggr,async_Loroeau,join_by(sample_ID,composition))

#async_aggr_f<-async_aggr%>%dplyr::filter(nutrients!="0.01 g/L")
async_aggr<-async_aggr%>%dplyr::mutate(rep_var=sub("_[^_]+$", "", sample_ID))


```


```{r}
#filter out completely extinct microcosms
 
#  
# async_df<-complete_ts%>%dplyr::mutate(rep_var=sub("_[^_]+$", "", sample_ID))
#  
# ### remove extinc
# async_df<-async_df%>%
#   group_by(predict_spec,sample_ID)%>%
# arrange(day) %>%
#   mutate(
#     # Create a flag for non-zero tot_biomass
#     non_zero_biomass = biomass != 0,
#     # Find the last non-zero day
#     last_non_zero_day = ifelse(any(non_zero_biomass), max(day[non_zero_biomass], na.rm = TRUE), NA),
#     # Find the first zero day after the last non-zero day
#     first_zero_day = ifelse(
#       !is.na(last_non_zero_day),
#       min(day[!non_zero_biomass & day > last_non_zero_day], na.rm = TRUE),
#       NA
#     ),
#     # Flag for days after the first zero day
#     is_after_first_zero_day = ifelse(!is.na(first_zero_day), day > first_zero_day, FALSE)
#   ) %>%
#   ungroup()
#  
# async_df<-async_df%>%dplyr::filter(is_after_first_zero_day==F)
#  
# async_Gross <- async_df %>% group_by(composition,sample_ID) %>%  
#   do(synchrony_Gross = synchrony(., "day", "predict_spec", 
#                               "biomass", metric = "Gross"))
# async_Gross<-dplyr::mutate(async_Gross,synchrony_Gross=synchrony_Gross%>%unlist())
#  
# async_Loroeau <- async_df %>% group_by(composition,sample_ID) %>%  
#   do(synchrony_L = synchrony(., "day", "predict_spec", 
#                               "biomass", metric = "Loreau"))
# async_Loroeau<-dplyr::mutate(async_Loroeau,synchrony_Loreau=synchrony_L%>%unlist())
#  
# async_aggr<-full_join(async_Gross,complete_aggr,join_by(sample_ID,composition))
#  
# async_aggr<-full_join(async_aggr,async_Loroeau,join_by(sample_ID,composition))
#  
# async_aggr_f<-async_aggr%>%dplyr::filter(nutrients!="0.01 g/L")
# async_aggr<-async_aggr%>%dplyr::mutate(rep_var=sub("_[^_]+$", "", sample_ID))
```



### Plot stability vs. Asynchrony Gross
```{r async_plots, fig.align="center", fig.height=6, fig.width=12}
plot_asynch_CV_G<-ggplot(data=async_aggr,aes(x=-synchrony_Gross,y=log10(1/CV),color=nutrients))+
  geom_point(size = 3.5, alpha = 0.65)+
  geom_smooth(method="lm",show.legend=F, linewidth = 2)+
  theme_classic()+
  scale_y_continuous(
    breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
    labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  ) +
   theme(axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
         axis.text = element_text(size = 20),      
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 25)) +
   ylab("Temporal stability\nlog(mean/s.d.)")+
  xlab("Asynchrony")+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)



plot_asynch_CV_G

```


**Figure 11**: Relationship between temporal stability and asynchrony (Gross) divided by nutrient level.




### Plot Asynchrony Gross vs fundamental imbalance

```{r async,  fig.align="center", fig.height=6, fig.width=12}

plot_asynch_B_G<-ggplot(data=async_aggr ,aes(x=log10(balance_f),y=-synchrony_Gross, col= nutrients))+
  geom_point(size = 3.5, alpha = 0.65)+
  geom_smooth(method="lm",show.legend=F, linewidth = 2)+
  theme_classic()+
   theme(axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
         axis.text = element_text(size = 20),      
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 25)) +
   xlab(expression(log10(Imbalance)["fund"] )) +
  ylab("Asynchrony")+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)



plot_asynch_B_G


```


## Eveness
Evenness in species biomass has been identified as an important factor potentially influencing ecosystem stability [Thibaut & Connolly 2013](https://onlinelibrary.wiley.com/doi/full/10.1111/ele.12019). In the context of our experiment, evenness in species biomass could help explaining why there is little difference between fundamental and realized imbalance. If evenness is high, then all species contribute similarly to total biomass. In this case, weighting for species-biomass contribution to total biomass (realized), should not fundamentally change the result, compared to an un-weighted (fundamental) measurement. 
```{r eveness,  fig.align="center", fig.height=6, fig.width=8}

even_aggr<- complete_ts %>%
  group_by(sample_ID,predict_spec,richness) %>% 
  summarize(mean_biom_contribution=mean(biom_contribution,na.rm=T)) %>%
  ungroup()
 
 
# exclude microcosms where all but one species 
even_aggr<- even_aggr %>% 
  dplyr::filter(!(mean_biom_contribution%in%c(0,1)))
 
even_aggr<- even_aggr %>% 
  group_by(sample_ID,richness) %>% 
  reframe(H= -sum(mean_biom_contribution*log(mean_biom_contribution)))

even_aggr<- even_aggr %>% 
  mutate(evenness=H/log(as.numeric(richness)))
 
even_aggr<- full_join(even_aggr,async_aggr,by=c("sample_ID"))
 
mean_evenness <- mean(even_aggr$evenness, na.rm = TRUE)

# Create the histogram with the mean indicated
dist_even <- ggplot(data = even_aggr, aes(x = evenness)) +
  geom_histogram(binwidth = 0.05, fill = "steelblue", color = "black", alpha = 0.7) + # Adjust binwidth for better visualization
  geom_vline(aes(xintercept = mean_evenness), color = "red", linetype = "dashed", size = 1.2) + # Add the mean line
  theme_classic() +
  labs(
    x = "Evenness",
    y = "Frequency",
    title = "Distribution of Evenness with Mean"
  ) +
  annotate("text", x = mean_evenness, y = 5, label = paste0("Mean = ", round(mean_evenness, 2)), 
           color = "red", hjust = -0.1, size = 5)

# Print the plot
dist_even
```

**Figure 12**: Distribution of species evenness across experimental communities. The histogram represents the frequency of observed evenness values, while the red dashed line indicates the mean evenness (0.4). This highlights the central tendency of evenness across the dataset and its variation among communities.

Evenness is lower when using the reduced time series, indicating possible larger role of dominance and population stability in the second part of the experiment. 

# Population stability

The relationship between community stability and the stability of the individual populations that make up the community is a key question in ecology. Importantly, ecosystem stability can result from low population stability, if populations fluctuate asynchronously, or from high population stability, if populations do not fluctuate much.
Synthesis of the literature suggests diversity can have a positive or negantive effect on population stability [Campbell et al 2010](https://nsojournals.onlinelibrary.wiley.com/doi/full/10.1111/j.1600-0706.2010.18768.x) and (Xu et al 2021)[https://onlinelibrary.wiley.com/doi/full/10.1111/ele.13777].

Theoretical work has suggested that community stability is a product of two quantities: the (a) synchrony of population fluctuations, and an average species-level population stability that is weighted by relative abundance [Thibaut & Connolly 2013](https://onlinelibrary.wiley.com/doi/full/10.1111/ele.12019). 

Critically, a imbalance value close to zero can result from high response diversity, but also from high population stability (population biomass does not change largely over time).
We want to look now at whether our new metric of imbalance can capture these two stabilising mechanisms.

Thus, we calculate species-level population stability weighted by relative abundance and look at how it relates to ecosystem stability. 

```{r echo=FALSE, warning=FALSE, results='hide'}


pop_aggr<-complete_ts%>%group_by(sample_ID,predict_spec)%>%summarize(pop_CV=sd(biomass)/mean(biomass),mean_biom_contribution=mean(biom_contribution,na.rm=T), pop_V= sd(biomass))

# Lehman & Tilman (2000), THIBAUT & Connolli (2013), Gross et al. (2014)

pop_aggr<-pop_aggr%>%group_by(sample_ID)%>%summarize(pop_V=sum(pop_V),
                                                     w_pop_CV=sum(pop_CV*mean_biom_contribution, na.rm=T))

pop_aggr<-pop_aggr%>%group_by(sample_ID)%>%full_join(async_aggr,pop_aggr,by="sample_ID")


plot_pop_aggr_balance <- ggplot(data = pop_aggr, aes(y = log10(stability), x = log10(1 / w_pop_CV), color = nutrients)) +
  geom_point(size = 3.5, alpha = 0.65) +
  geom_smooth(method = "lm", linewidth = 2, show.legend = F) +
  theme_classic(base_size = 25) +
  scale_color_viridis_d(option = "plasma", begin= 0.15, end= 0.85 ) +  # Use plasma palette
  labs(x = "log10(population stability)", y = "Temporal stability\nlog(mean/s.d.)")


plot_pop_aggr_balance

#ggsave("figures_ms/fig.pop_stab.png", plot = plot_pop_aggr_balance, width = 9, height = 6, dpi = 600)

# cor.test(pop_aggr$w_pop_CV,pop_aggr$stability)



```
**Figure 14**: Relationship between log10 of population stability and log 10 of ecosystem stability.  


```{r pop_balance,  fig.align="center", fig.height=6, fig.width=12}
plot_pop_balance<- pop_aggr %>% #dplyr::filter(nutrients != "0.01 g/L") %>%
  ggplot(aes(x=log10(balance_f), y = log10(1 / w_pop_CV),color=nutrients))+
  geom_point(size = 3.5, alpha = 0.65)+
  geom_smooth(method="lm",show.legend=F, linewidth = 2)+
  theme_classic()+
   theme(axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
         axis.text = element_text(size = 20),      
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 25)) +
   xlab(expression(log10(Imbalance)["fund"] )) +
  ylab("Population stability")+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)


plot_pop_balance
```

**Figure 15**: Relationship between fundamental imbalance and population stability divided by nutrient level.

```{r}
fig4 <- (plot_asynch_CV_G + plot_pop_aggr_balance) /
                 (plot_asynch_B_G + plot_pop_balance) +
  plot_layout(guides = "collect") &
  theme(
    legend.position = "right",
    legend.direction = "vertical",
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 18),
    legend.key.size = unit(1.5, "lines"),
    plot.tag = element_text(size = 25)
  )

# Add (a), (b), (c), (d) tags
fig4 <- fig4 + plot_annotation(tag_levels = 'a', tag_prefix = "(", tag_suffix = ")")

#ggsave("figures_ms/fig4.png", plot = fig4, width = 18, height = 12, dpi = 600)
```

# SEM 

Finally, we use a structural equation model (SEM) to explore how stability is influenced by asynchrony, population stability, imbalance and, nutrient levels. 
In order to develop a hypothesis regarding the influence of stability, we have drawn on existing literature. This has enabled us to posit that stability is influenced by two key factors: asynchrony and population stability. In turn, these are influenced by balance and, in our particular case, by nutrient levels.
The model presented in the main text did not fit this portion of data well, we thus switched to a piecewise SEM approach, which allows us to fit a series of linear models and then combine them into a single SEM model. This approach is more flexible and can be more robust to violations of the assumptions of SEM.


```{r}

pop_aggr <- left_join(pop_aggr, even_aggr, by = "sample_ID")

sem_aggr3 <- pop_aggr %>% 
  ungroup() %>%  # Ensure there is no grouping
  mutate(
    log_balance_f = log10(balance_f.x),
    stability = log10(1 / CV.x),
    richness = as.numeric(richness.x),
    temperature=temperature.x,
    asynchrony_Gross= (-synchrony_Gross.x),
    pop_stability= log10(1/w_pop_CV),
    pop_var = log10(pop_V),
    evenness = evenness
    #Keep it as an ordered factor
  )

#replace NA with 0
sem_aggr3[] <- lapply(sem_aggr3, function(x) {
  if (is.numeric(x)) {
    x[!is.finite(x)] <- 0
  }
  return(x)
})


# 
# 
# model1C <- '
#   stability ~ 
#   +pop_stability 
#   +asynchrony_Gross
#  
#  asynchrony_Gross~log_balance_f 
#   
#   
#   pop_stability~log_balance_f 
#  
#   
# 
# '
# 
# 
# 
# 
# # Fit the model
# 
# fit1C <- sem(model1C,estimator="MLM",meanstructure = TRUE,data = sem_aggr3)
# #modificationindices(fit1C)
# 
# # Summarize the results
# summary(fit1C, standardized = TRUE,rsquare=T, fit.measures = TRUE)

```

```{r}
library(piecewiseSEM)
# 1. Clean
sem_aggr3_clean <- sem_aggr3 %>%
  na.omit() %>%
  mutate(
    temperature = case_when(
      temperature == "18-21 °C" ~ 1,
      temperature == "22-25 °C" ~ 2,
      temperature == "25-28 °C" ~ 3,
      TRUE ~ NA_real_
    ),
    nutrients = case_when(
      nutrients.x == "0.01 g/L" ~ 1,
      nutrients.x == "0.35 g/L" ~ 2,
      nutrients.x == "0.75 g/L" ~ 3,
      TRUE ~ NA_real_
    ),
    temperature = factor(temperature),
    nutrients = factor(nutrients)
  ) %>%
  na.omit()

# 2. Fit models
mod1 <- lmer(stability ~  pop_stability + asynchrony_Gross +
               (1 | nutrients) + 
               (1 | temperature),
             data = sem_aggr3_clean)

mod2 <- lm(asynchrony_Gross ~ log_balance_f,
             data = sem_aggr3_clean)     
mod3 <- lm(pop_stability ~ log_balance_f,
             data = sem_aggr3_clean)

# 3. Piecewise SEM
fit_psem <- psem(mod1, mod2, mod3)
#summary(fit_psem)


```

**Table 15**: Results of the piecewise SEM.

```{r}
# Extract and clean path coefficients
path_matrix <- summary(fit_psem)$coefficients

# Fix unnamed columns
colnames(path_matrix) <- make.names(colnames(path_matrix), unique = TRUE)

# Convert to a clean tibble
path_table <- path_matrix %>%
  as.data.frame() %>%
  dplyr::rename(
    Std_Error = `Std.Error`,
    Crit_Value = `Crit.Value`,
    p_value = `P.Value`,
    Std_Estimate = `Std.Estimate`
  ) %>%
  dplyr::mutate(
    Response = dplyr::case_when(
      Response == "synchrony_Gross.x" ~ "Asynchrony",
      Response == "pop_stability" ~ "Population Stability",
      TRUE ~ Response
    ),
    Predictor = dplyr::case_when(
      Predictor == "pop_stability" ~ "Population Stability",
      Predictor == "synchrony_Gross.x" ~ "Asynchrony",
      Predictor == "log_balance_f" ~ "log10(imbalance)",
      TRUE ~ Predictor
    ),
    p_value = round(p_value, 3)
  )
# Format with gt
path_table %>%
  gt() %>%
  cols_label(
    Response = "Response",
    Predictor = "Predictor",
    Estimate = "Estimate",
    Std_Error = "SE",
    DF = "DF",
    Crit_Value = "t-value",
    p_value = "p-value",
    Std_Estimate = "Standardized Estimate"
  ) %>%
  fmt_number(columns = where(is.numeric), decimals = 3) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(columns = p_value, rows = p_value < 0.05)
  ) %>%
  tab_header(title = "Path Coefficients (Piecewise SEM)")


```

In the last 20 days of the experiment, population stability dominates the effect on stability. 
