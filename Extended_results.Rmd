---
title: "Extended results for: The balance of nature relies on response diversity for stability"
author: "Til Hämmig, Francesco Polazzo"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    code_folding: hide
    keep_md: yes
    fig_caption: true  
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
rm(list=ls())
library("ggplot2")
library("tidyverse")
library("gridExtra")
#library(rEDM)
library("parallel")
library("pracma")
library("purrr")
library("signal")
library("ggfortify")
library("data.table")
library("patchwork")
library("codyn")
library("ggrepel")
library("lme4")
library("lmerTest")
library("MuMIn")
library("RColorBrewer")
library("broom")
library("relaimpo")
library("lavaanPlot")
library(ggbeeswarm)
library(performance)
library(broom)
library(kableExtra)
library(gt)
library(lavaan)
#devtools::install_github("canankarakoc/r_package_EDMhelper/EDMhelper")

```

```{r include = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      include = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      cache = FALSE)
```


# Introduction

The purpose of this document is to provide a reproducible record of all analyses and figures in the main article. The main article is focused on the effect of response diversity on community stability in fluctuating environments. We are going to look at the effect of response diversity, richness, temperature and nutrients on community temporal stability. Specifically, we are going to look at the effect of fundamental balance (our measurement of stability) on temporal stability. Then, as response diversity is thought to stabilize temporal stability of aggregate community properties via asynchrony, we are going to look at the relationship between response diversity and asynchrony. 
Finally, as multiple evidence suggests that compensatory dynamics and temporal stability are determine by species interactions, we are going to analyse the effect of species interactions on stability to understand if they are more important than response diversity in driving temporal stability of community biomass.

This document is produced by an Rmarkdown file that includes code to reproduce from data all results presented in the main article.



# Load datasets, Data wrangling and balance calculation

```{r echo = TRUE, include=T, warning=FALSE, results='hide'}

divergence_df <- read_csv("Data/divergence_df.csv")
load("Data/dens_biomass_poly.RData")

dd_all_pred<-read.csv("Data/morph_dd_pred.csv")
dd_all_pred_nonoise<-read.csv("Data/morph_dd_pred_nonoise.csv")

load("Data/ciliate_traits.Rdata")

df_slopes <- read_csv("Data/df_slopes_cor.csv")

# needs to have id_new variable
ciliate_traits <- ciliate_traits %>%
  dplyr::mutate(
    # Remove dots from the date
    cleaned_date = gsub("\\.", "", date),
    # Extract the part of id after the underscore
    id_suffix = sub(".*_(.*)", "\\1", id),
    # Combine cleaned_date, id_suffix, and species_initial into a new variable
    id_new = paste0(cleaned_date, id_suffix, composition)
  ) %>%
  # Optionally, remove the intermediate columns to clean up
  dplyr::select(-cleaned_date, -id_suffix,-new_id)

uniqueN(ciliate_traits$id_new)==nrow(ciliate_traits) # all unique  ;)

id_dd<-full_join(dd_all_pred,dplyr::select(ciliate_traits,id_new,biomass),join_by("id_new"))


## add day variable

#create a day variable from the date variable

id_dd<-dplyr::mutate(id_dd,date=as.Date(date,format = "%d.%m.%y"))

earliest_date<-min(id_dd$date)
days_since_earliest<-as.numeric(id_dd$date-earliest_date)+1
id_dd<-id_dd%>%dplyr::mutate(day=days_since_earliest)

#create a summarised df on microcosm level with each species seperate
# Make sure, that we have n_frames and not N_frames
names(id_dd)[names(id_dd) == "N_frames"] <- "n_frames"

#extrapolation_factor <- 9.301902  # for 16 x magnification 
extrapolation_factor <- 9.828125  # for 25 x magnification 
video_biomass_species <- c( "C", "P", "S","D","L","T")

biomasses <- id_dd %>%
  dplyr::group_by( day,temperature,nutrients,sample_ID,composition,predict_spec) %>% # group  by xxx
  dplyr::summarize(
    biomass = sum(biomass * n_frames, na.rm = TRUE) / (1 * 125) # if not 3 videos corrections is done below with dens_factor
  ) %>%
  dplyr::mutate(
    biomass = biomass * extrapolation_factor,
    )

biomasses<-biomasses%>%dplyr::mutate(biomass=biomass*1000)

dd_ts_id<-biomasses

#fill up missing dates with biomass<-0

fill_dd<-expand.grid(sample_ID=unique(dd_ts_id$sample_ID),day=unique(dd_ts_id$day),predict_spec=unique(dd_ts_id$predict_spec))
complete_ts<-full_join(fill_dd,dd_ts_id,join_by(sample_ID,day,predict_spec))

complete_ts$biomass[is.na(complete_ts$biomass)]<-0
complete_ts<-complete_ts%>%dplyr::mutate(composition=sub("_.*", "", sample_ID))
complete_ts<-complete_ts %>%
  dplyr::mutate(temperature = sapply(strsplit(as.character(sample_ID), "_"), function(x) paste(x[3], x[4], sep = "-")))
complete_ts<- dplyr::mutate(complete_ts,nutrients = gsub(".*Nut(.*?)_.*", "\\1", sample_ID))

# Now remove wrong combinations of composition and predict_spec / predict_spec

complete_ts<- complete_ts %>%
  rowwise() %>%
  dplyr::filter(predict_spec %in% unlist(strsplit(composition, ""))) %>%
  ungroup()  
complete_ts<-dplyr::mutate(complete_ts,temperature=as.character(temperature),
                    nutrients=as.character(nutrients),
                    richness=nchar(composition))

complete_ts<-complete_ts%>%group_by(sample_ID,composition,day)%>%dplyr::mutate(tot_biomass=sum(biomass))
complete_ts<-complete_ts%>%dplyr::mutate(biom_contribution=biomass/tot_biomass)

df_biomass_mod <- complete_ts

complete_ts<-complete_ts%>%dplyr::mutate(temperature=paste0(temperature," °C"),
                                      nutrients=paste0(nutrients," g/L"))


# introduce slopes of 
names(df_slopes)[names(df_slopes)=="species_initial"]<-"predict_spec"

slope_ts<-full_join(dplyr::select(df_slopes,nutrients,predict_spec,temperature,slope),complete_ts)
slope_ts<-slope_ts%>%dplyr::mutate(w_slope=biom_contribution*slope,
                            sign=sign(slope))

slope_ts<-slope_ts%>%group_by(sample_ID,temperature,nutrients,richness,composition,day,tot_biomass)%>%dplyr::summarize(
  sum_w_slopes=abs(sum(w_slope)),
                   mean_abs_slope=mean(abs(slope)),
  sum_abs_slope=sum(abs(slope)),
  abs_sum_slope=abs(sum(slope)),
  symmetry=abs(sum(sign)))


slope_ts<-slope_ts%>%dplyr::mutate(richness=as.factor(richness))


##create new variable where it checks, where the last observation =0 is; with complete_ts
aggr_ts <- slope_ts %>%
  group_by( sample_ID) %>%
  arrange(day) %>%
  mutate(
    # Create a flag for non-zero tot_biomass
    non_zero_biomass = tot_biomass != 0,
    # Find the last non-zero day
    last_non_zero_day = ifelse(any(non_zero_biomass), max(day[non_zero_biomass], na.rm = TRUE), NA),
    # Find the first zero day after the last non-zero day
    first_zero_day = ifelse(
      !is.na(last_non_zero_day),
      min(day[!non_zero_biomass & day > last_non_zero_day], na.rm = TRUE),
      NA
    ),
    # Flag for days after the first zero day
    is_after_first_zero_day = ifelse(!is.na(first_zero_day), day > first_zero_day, FALSE)
  ) %>%
  ungroup()

aggr_ts<-aggr_ts%>%mutate(rep_var=sub("_[^_]+$", "", sample_ID))

biomass_ts<-aggr_ts%>%group_by(day,temperature,nutrients,richness)%>%summarize(tot_biom=mean(tot_biomass),se_tot_biom=sd(tot_biomass)/sqrt(as.numeric(length(tot_biomass))))


```


# Biomass

Let's have a look at the biomass dynamics in the different environmental treatments.

### tot biomass plot

```{r plot_biomass, fig.align="center", fig.height=8, fig.width=15}

plot_biomass<-ggplot(data=biomass_ts)+
  geom_ribbon(aes(x=day,y=tot_biom,fill=richness,color=richness,ymin=tot_biom-se_tot_biom,ymax=tot_biom+se_tot_biom),show.legend=F,alpha=0.5)+
  geom_line(method="loess",se=F,aes(x=day,y=tot_biom,color=richness),size=0.8)+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
   scale_fill_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  theme_classic()+
  #geom_text_repel( data=biomass_ts%>%dplyr::filter(day==58,tot_biom!=0),aes(x=day,y=tot_biom,group=composition,label = composition), size = 4,max.overlaps = 20) +
  facet_wrap(temperature~nutrients,scale="free_y")+
  theme(axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 12))+
  ylab(expression("Community biomass [mg ml"^-1 * "]"))
  
plot_biomass
```

 **Figure 1** : Community total biomass during the experiment in different environmental treatments. Different color represent richness levels.



# Main Results 

We now look at the main results of the experiment. We are going to look first at the effect of richness, temperature and nutrients on community temporal stability. Then, we are going to look at the relationship between divergence (original response diversity metric) and temporal stability. Finally, we are going to look at the relationship between response diversity and temporal stability.

In the whole analysis, we calculated the temporal stability of total community biomass as the inverse of the coefficient of variation (ICV) (i.e. $\frac{\sigma}{\mu}$). 
```{r results='hide', echo=FALSE, warning=FALSE}
## discard all the rows that are part of time stretches where entire microcosms has (seemingly) gone extinct
#%>%dplyr::filter(is_after_first_zero_day==FALSE)

complete_aggr<-aggr_ts %>%group_by(composition,nutrients,temperature,sample_ID)%>%reframe(
  avg_w_sumslopes=mean(sum_w_slopes,na.rm = T),
  abs_sum_slope=mean(abs_sum_slope),
  magnitude=mean(mean_abs_slope),
  symmetry=mean(symmetry),
  sum_abs_slope=mean(sum_abs_slope),
  CV=sd(tot_biomass)/mean(tot_biomass),
  mean_biomass=mean(tot_biomass))

complete_aggr<-full_join(divergence_df,complete_aggr,by=join_by(composition,nutrients,temperature))%>%
  mutate(richness=as.factor(richness))




```

### Effect of T, N and R
```{r boxplots_TNR, results='hide', echo=FALSE, warning=FALSE, fig.align="center", fig.height=8, fig.width=12}
#### effects of temperature; nutrient and richness, now with complete time series

plot_T_complete<-ggplot(data=complete_aggr)+
  geom_boxplot(aes(y=log10(1/CV),x=temperature))+
  geom_jitter(aes(y=log10(1/CV),x=temperature))

plot_T_complete<-ggplot(data=complete_aggr)+theme_bw(base_size = 25)+
  geom_quasirandom(data= complete_aggr,aes(y=log10(1/CV), x=temperature, group=temperature, colour=as.factor(temperature)),
                                  dodge.width=2, size=2.5) + 

  xlab("Temperature regime")+
  labs(color="Temperature regime", tag = "(b)")+
  theme(legend.position = "none",axis.title.y = element_blank())+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  scale_y_continuous(
    breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
    labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  ) 


plot_N_complete<-ggplot(data=complete_aggr)+
  geom_boxplot(aes(y=log10(1/CV),x=nutrients))+
  geom_jitter(aes(y=log10(1/CV),x=nutrients,color=richness))

plot_N_complete<-ggplot(data=complete_aggr)+ theme_bw(base_size = 25)+
  geom_quasirandom(data= complete_aggr,aes(y=log10(1/CV), x=nutrients, group=nutrients, colour=as.factor(nutrients)),
                                  dodge.width=2, size=2.5) + 

  xlab("Nutrients")+
  theme(legend.position = "none",axis.title.y = element_blank())+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  scale_y_continuous(
    breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
    labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  ) + labs(tag = "(c)")

plot_R_complete<-ggplot(data=complete_aggr)+
  geom_boxplot(aes(y=log10(1/CV),x=richness))+
  geom_jitter(aes(y=log10(1/CV),x=richness))

plot_R_complete<-ggplot(data=complete_aggr)+theme_bw(base_size = 25)+
  geom_quasirandom(data= complete_aggr,aes(y=log10(1/CV), x=richness, group=richness, colour=as.factor(richness)),
                                  dodge.width=2, size=4) + 

  
  
  xlab("Richness")+
  theme(legend.position = "none",
        axis.title.y = element_blank())+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  scale_y_continuous(
    breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
    labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  ) + labs (tag = "(a)") 

combined_plot<-plot_R_complete/
(plot_T_complete+
plot_N_complete)

combined_plot<- wrap_elements(combined_plot) +
  labs(tag = "Temporal stability\nlog(mean/s.d.)")+
  theme(
    plot.tag = element_text(size = rel(2.5), angle = 90),
    plot.tag.position = "left"
  )
combined_plot
# expression(atop("Temporal stability", log[10]("mean/s.d.")))
#ggsave("figures_ms/fig.1.png", plot = combined_plot, width = 14, height = 8, dpi = 600)


```
**Figure 2**: Effects of richness (a), temperature (b), and nutrients (c) on community total biomass temporal stability.



We can see that richness does not have a clear effect on community temporal stability, while stability was higher at lower temperature, and nutrients increased community temporal stability.

### Effect of Divergence

We look at the relationship between divergence (our original response diversity metric) and stability

```{r divergence_CV, results='hide', echo=FALSE, warning=FALSE, fig.align="center", fig.height=10, fig.width=16}

plot_CV_divergence<-complete_aggr%>%ggplot(aes(x=divergence,y=log10(1/CV),color=richness))+
  geom_point(size = 3.5, alpha = 0.65)+
  geom_smooth(method="lm",aes(x=divergence,y=log10(1/CV),color=richness),show.legend=F, linewidth = 2)+theme_classic()+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+
  scale_y_continuous(
    breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
    labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  ) +
    theme(
    axis.title.x = element_text(size = 25),
    axis.title.y = element_text(size = 25),
    axis.text = element_text(size = 14),                      # Axis text size             # Facet label text size
    legend.title = element_text(size = 20),                   # Legend title size
    legend.text = element_text(size = 20),                     # Legend text size
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 22)) +
  facet_wrap(~richness, labeller = as_labeller(function(x) paste0("richness = ", x)))+
  ylab("Temporal stability\nlog(mean/s.d.)")+
  xlab("divergence") 


plot_CV_divergence

```


**Figure 3**: Relationship between Divergence and temporal stability of total community biomass.



Divergence is positively related to temporal stability, suggesting that response diversity promotes stability. However, the relationship between divergence and stability becomes weaker as richness increases. We think that this is due to divergence considering only the responses of the 2 most "responding" species. Thus, when species richness increases, disregarding the responses of the other species in the community except the 2 responding the most makes the relationship between response diversity and stability weaker. 

This is why, after running the experiment, we developed another metric to measure response diversity, which we called **balance**, and that is presented in the main text of the publication. 
Balance has several desirable features that makes it a more suitable metric than divergence: Independence of richness, higher predictive power, and accounts for the responses of all species in the community (as opposed to divergence that accounts for only the 2 most "responding" species).

Here, we provide extensive evidence of why balance is a better metric to measure response diversity than divergence, and thus justifying focusing the analysis around balance.

# Comparing Divergence and Balance

## Predictive power of Divergence and Balance

We first compare how well divergence and balance predict stability (predictive power). 

```{r results='hide', echo=FALSE, warning=FALSE, message=FALSE}

complete_aggr <- complete_aggr %>% mutate(stability = 1/CV) %>% 
  dplyr::rename(balance_f = abs_sum_slope,
                balance_r = avg_w_sumslopes)



# summary(lm_full)
# anova(lm_full)
```

### Balance

```{r model_check1, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
# 

mod1 <- lm(data=complete_aggr,log10(stability)~log10(balance_f))

# Check model assumptions
#check_model(mod1)

```



### Divergence
```{r model_check2, include=TRUE, echo=TRUE, fig.align="center", fig.height=9, fig.width=12}
mod2 <- lm(data=complete_aggr,log10(stability)~(divergence))

# Check model assumptions
#check_model(mod2)

```



**Table 1**: Comparison of model performance of divergence and balance as predictors of stability. Model 1 has balance as predictor and model 2 has divergence as predictor.
```{r}
# compare performance tables of mod1 and mod2 specifying 
performance(mod1) %>% 
  bind_rows(performance(mod2), .id = "model") %>% 
  kable() %>% 
  kable_styling(full_width = F)
```

A model with Balance as predictor performs better than one with divergence as predictor, and it explains more of the variance in stability than divergence.



Moreover, from **Figure 3**, it looks like divergence declines in performance as richness increases. Let's test this analytically.
To do than we build a linear model having stability as response variable and either log10(balance) or divergence as predictor for each richness level. We then extract the R squared of the models and their *standardised* estimates. (standardized estimates were calculated centering divergence and balance using the function scale()).

```{r include = TRUE, echo=TRUE}
# getting model estimates for each richness level
lm_divergence_richness_E <- complete_aggr %>%
  nest(data = -richness) %>%
  mutate(
    model = map(data, ~ lm(log10(stability) ~ scale(divergence), data = .x)),
    results = map(model, broom::tidy)
  ) %>%
  unnest(results) %>% dplyr::filter(term=="scale(divergence)") 


# getting model R squared for each richness level

lm_divergence_richness_R <- complete_aggr %>%
  nest(data = -richness) %>%
  mutate(
    model = map(data, ~ lm(log10(stability) ~ scale(divergence), data = .x)),
    results = map(model, broom::glance)
  ) %>%
  unnest(results) 

```


```{r include = TRUE, echo=TRUE}

# getting model estimatesf or each richness level
lm_balance_richness_E <- complete_aggr %>%
  nest(data = -richness) %>%
  mutate(
    model = map(data, ~ lm(log10(stability) ~ scale(log10(balance_f)), data = .x)),
    results = map(model, broom::tidy)
  ) %>%
  unnest(results) %>% dplyr::filter(term=="scale(log10(balance_f))") 



# getting model R squared for each richness level
lm_balance_richness_R <- complete_aggr %>%
  nest(data = -richness) %>%
  mutate(
    model = map(data, ~ lm(log10(stability) ~ scale(log10(balance_f)), data = .x)),
    results = map(model, broom::glance)
  ) %>%
  unnest(results) 

```


```{r R_squared, fig.align="center", fig.height=5, fig.width=15}
# plot how the r squared changes with richness for divergence and balance with legend and lines with diamond instead of points


a <- ggplot(data = lm_divergence_richness_R, aes(x = richness, y = r.squared, color = "Divergence")) +
  geom_point( shape = 18, cex = 5 )  +
  geom_point(data = lm_balance_richness_R, aes(x = richness, y = r.squared, color = "Balance"), shape = 18, cex = 5 ) +
  labs(x = "Richness", y = "R squared", color = "Model") +
theme_minimal(base_size = 20) +
  scale_color_manual(values = c("Divergence" = "blue", "Balance" = "red"))+ labs(tag = "(a)")


# plot how the estinmates changes with richness for divergence and balance with legend and lines
b <- ggplot(data = lm_divergence_richness_E, aes(x = richness, y = estimate, color = "Divergence") ) +
  geom_point(shape = 18, cex = 5) +
  geom_point(data = lm_balance_richness_E, aes(x = richness, y = abs(estimate), color = "Balance"), shape = 18, cex = 5 ) +
  labs(x = "Richness", y = "Estimate", color = "Model") +
  theme_minimal(base_size = 20) +
  scale_color_manual(values = c("Divergence" = "blue", "Balance" = "red")) + labs(tag = "(b)")

a + b

```
**Figure 4**: Performance comparison of divergence vs balance. In (a), the R squared of linear models for divergence and balance are shown for each richness level. In (b), the estimates of the linear models for divergence and balance are shown for each richness level.




We can see that the R squared of divergence as predictor of stability becomes smaller as richness increases, while the R squared of balance as predictor of stability does not (actually increases slightly). 


## Comparing unique explanatory power of balance and divergence

Now we build a linear model were stability is modeled as a function of balance and divergence. 
Then, we compared the variance explained by the full model compared to a model containing either only balance or only divergence.


### Full model - balance and divergence

```{r model_check3, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
lm_div_balance <- lm(data=complete_aggr,log10(stability)~log10(balance_f)+divergence)

# Check model assumptions
# check_model(lm_div_balance)
```



### model with only divergence
```{r model_check4, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
lm_div <- lm(data=complete_aggr,log10(stability)~divergence)

# Check model assumptions
# check_model(lm_div)
```




### model with only balance
```{r model_check5, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
lm_balance <- lm(data=complete_aggr,log10(stability)~log10(balance_f))

# Check model assumptions
# check_model(lm_balance)
```


### Comparision full model vs divergence only and balance only


**Table 2**: Comparison of model performance of divergence, balance and both as predictors of stability. Model 1 has both balance and divergence as predictors, model 2 has divergence as predictor, and model 3 has balance as predictor.
```{r}
# compare performace tables of lm_div_balance, lm_div and lm_balance
performance(lm_div_balance) %>% 
  bind_rows(performance(lm_div), .id = "model") %>% 
  bind_rows(., performance(lm_balance), .id = "model") %>% 
  kable() %>% 
  kable_styling(full_width = F)

```



### Comparision full model vs balance only

**Table 3**: Anova table: a model with both balance and divergence as predictors is not significantly different from a model with only balance as predictor.
```{r include = TRUE, echo=TRUE}
anova1 <- anova(lm_div_balance,  lm_balance)

# Convert to tidy format
anova_tidy1 <- broom::tidy(anova1)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy1 %>%
  gt() %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(12),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )


```


### Comparision full model vs divergence only and divergence only

**Table 4**: Anova table: a model with both balance and divergence as predictors is significantly better from a model with only divergence as predictor.
```{r include = TRUE, echo=TRUE}
anova2 <- anova(lm_div_balance,  lm_div)


anova_tidy2 <- broom::tidy(anova2)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy2 %>%
  gt() %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(12),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )

```

Overall, balance explains more of the variance in stability than divergence, and there is virtually no difference between a model containing only balance and the full model.




## Interaction divergence and richness

Richness had to be transformed to numeric and to be centered to avoid collinearity with divergence

```{r model_check6, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}


lm_rich_div <- lm(data=complete_aggr,log10(stability)~divergence*scale(as.numeric(richness)))

# check model assumptions
# check_model(lm_rich_div)
```




**Table 5**: Type III anova table of the model with divergence and richness as predictors of stability.
```{r include = TRUE, echo=TRUE}
anova3 <- car::Anova(lm_rich_div, type = "III")

anova_tidy3 <- broom::tidy(anova3)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy3 %>%
  gt() %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(12),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )

```


Divergence significantly interact with richness, suggesting that the relationship between divergence and stability changes with richness. 
While an ideal metric of response diversity should be independent of richness.



We repeat the same model using balance instead of divergence.
```{r model_check7, fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE}
lm_rich_balance <- lm(data=complete_aggr,log10(stability)~log10(balance_f)*scale(as.numeric(richness)))

# check model assumptions
# check_model(lm_rich_balance)
```





**Table 6**: Type III anova table of the model with balance and richness as predictors of stability.
```{r include = TRUE, echo=TRUE}
anova4 <- car::Anova(lm_rich_balance, type = "III")

anova_tidy4 <- broom::tidy(anova4)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy4 %>%
  gt() %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(12),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )

```

Balance does not significantly interact with richness, suggesting that the relationship between balance and stability is stable across richness levels.


## Variable importance

Finally, we assess variable importance using the relative importance of predictors in the full model.
We use the package vip (https://cran.r-project.org/web/packages/vip/vignettes/vip.html) to calculate the relative importance of predictors in the full model.
The function vip::vip for multiple linear regression, or linear models (LMs), uses the absolute value of the -statistic  as a measure of VI.
Motivation for the use of the associated 𝑡-statistic is given in Bring (1994) [https://www.tandfonline.com/doi/abs/10.1080/00031305.1994.10476059].

```{r vip1, fig.align="center", fig.height=4, fig.width=8, include=TRUE, echo=TRUE}
vip::vip(lm_div_balance)
```
**Figure 5**: Variable importance in the model including both balance and divergence as predictors of stability.


We believe that the extensive evidence here provided justifies focusing the analysis around balance, and not divergence, as a metric of response diversity.
We will thus only look at balance for the rest of the analysis. 

# Effect RD

We are now going to look at how response diversity (balance) affected temporal stability of total community biomass. We are going to look at the relationship between fundamental balance (so based only on species response surfaces measured in monoculture), an realised balance (measured accounting for species contribution to balance).

This is fundamentally testing our most important hypothesis.

```{r effect_RD, results='hide', echo=FALSE, warning=FALSE, fig.align="center", fig.height=10, fig.width=20}

balance_dd<-complete_aggr%>%dplyr::select(balance_f,richness,CV)%>%
  cbind(type="fundamental")%>%mutate(balance_f=balance_f/as.numeric(richness))
names(balance_dd)[names(balance_dd)=="balance_f"]<-"balance"

weighted_balance_dd<-complete_aggr%>%dplyr::select(balance_r,richness,CV)%>%
  cbind(type="realised")
names(weighted_balance_dd)[names(weighted_balance_dd)=="balance_r"]<-"balance"

main_r_dd<-rbind(balance_dd,weighted_balance_dd)


plot_main <- main_r_dd %>%
  ggplot(aes(x = (log10(balance)), y = log10(1/CV), color = type)) +
  geom_point(aes(x = log10(balance), y = log10(1/CV)), size = 3.5, alpha = 0.65) +
  geom_smooth(method = "lm", aes(x = log10(balance), y = log10(1/CV)), linewidth = 2, show.legend=F) +
  theme_classic() +
  scale_color_viridis_d(option = "inferno", begin = 0.3, end = 0.6) +
  # scale_x_continuous(
  #   breaks = log10(c(0.0025,0.01, 0.04, 0.16, 0.64)),
  #   labels = c("0.0025","0.01", "0.04", "0.16", "0.64")
  # ) +
  # scale_y_continuous(
  #   breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
  #   labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  #) +
  ylab("Temporal stability\nlog(mean/s.d.)")+
  xlab("log10(balance)") +
 theme(
    axis.title.x = element_text(size = 25),
    axis.title.y = element_text(size = 25),
    axis.text = element_text(size = 20),                      # Axis text size             # Facet label text size
    legend.title = element_text(size = 25),                   # Legend title size
    legend.text = element_text(size = 25),                     # Legend text size
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 25)) +
  labs(color = "balance") +  
  facet_wrap(~richness, labeller = as_labeller(function(x) paste0("richness = ", x)))

plot_main

#ggsave("figures_ms/fig.2.png", plot = plot_main, width = 20, height = 10, dpi = 600)
```
**Figure 6**: Effects of fundamental and realised response diversity (measured as balance) on total community biomass temporal stability.


We can see that balance is always negatively related to temporal stability, which means that response diversity promotes stability across richness levels. Interestingly, we see that there is little difference between fundamental and realised balance. Yet, as the richness increases, the relationship between realised balance and stability becomes steeper compared to fundamental balance. 


But is the difference in the slope of fundamental and realised balance significant? We can test this using a linear model with interaction between balance and type (factor: fundamental or realised balance).


## Balance: realised vs fundamental
```{r include=TRUE, echo=TRUE}
# compare if the slope of fundamental and realised balance is significantly different for each richness level
# Fit the linear model with interaction
model_F <- lm(log10(1/CV) ~ log10(balance_f) , data = complete_aggr)
model_R_F <- lm(log10(1/CV) ~ log10(balance_f) +log10(balance_r) , data = complete_aggr)

```

**Table 7**: Anova table of the model with only realised balance vs one with both realised and fundamental balance as predictors of stability.
```{r include = TRUE, echo=TRUE}
anova5 <- anova(model_F, model_R_F)

anova_tidy5 <- broom::tidy(anova5)
# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy5 %>%
  gt() %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(12),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )

```

**Table 7**: Linear model results for the interaction between balance and type (fundamental vs realised) as predictors of stability for richness level.
```{r}
# produce publication ready anova table using gtsummary

performance(model_F) %>% 
  bind_rows(performance(model_R_F), .id = "model") %>% 
  kable() %>% 
  kable_styling(full_width = F)

```

A model with both fundamental and realised balance as predictors improved very little the variance explained by the model.




# Linear models


## Model: Fundamental balance

First we analyze the effect of fundamental balance, temperature, nutrients and richness on biomass temporal stability using a linear model. 
balance was modelled as continuous variables, while richness, temperature and nutrients were modelled as categorical variables. balance and stability were log-transformed to meet the assumptions of linear models.


```{r include=TRUE, echo=TRUE}
lm_full<-lm(data=complete_aggr,log10(stability)~log10(balance_f)+(richness)+nutrients+temperature)

# check model assumptions
# check_model(lm_full)
```

**Table 8**: Linear model results for the effects of balance, richness, nutrients, and temperature on community stability. Estimates are presented with 95% confidence intervals and p-values. 
```{r}
# produce publication ready table using gtsummary::tbl_regression

# Generate the regression table with enhanced styling

gtsummary::tbl_regression(lm_full,
               add_estimate_to_reference_row = TRUE, # Adds reference values for categorical predictors
               add_pairwise_contrasts = TRUE) %>% 
  # Customize table elements
  gtsummary::modify_header(label = "**Predictor**", estimate = "**Estimate**", conf.int = "**95% CI**", p.value = "**p-value**") %>%
  gtsummary::modify_footnote(everything() ~ NA) %>% # Remove default footnotes for clean look
  gtsummary::modify_spanning_header(c("estimate",  "p.value") ~ "**Linear Regression Results**") %>% # Title
  gtsummary::bold_labels() %>%
  gtsummary::as_gt() 

```


A linear model was fitted to examine the effects of resource balance, richness, nutrients, and temperature on community stability (measured as log₁₀(stability)). 


Among the predictors, log₁₀(balance) showed a significant negative effect on stability (Estimate = -0.05, SE = 0.016, p< 0.001). This suggests that as balance increases (more balance), stability tends to decrease.

Richness did not have a significant effect on stability within the conditions of this study.


Nutrient concentration also had a significant positive effect on stability, with estimates for 0.35 g/L (Estimate = 0.18, SE = 0.019, p < 0.001) and 0.75 g/L (Estimate = 0.21, SE = 0.019, p < 0.001) indicating increased stability with higher nutrient levels, when compared to the baseline (0.01 g/L).

Finally, temperature regimes showed a significant effect on stability. Both 22–25 °C (Estimate = -0.08, SE = 0.019, p < 0.001) and 25–28 °C (Estimate = -0.10, SE = 0.02, p < 0.001) significantly reduced stability when compared to the baseline (18–21 °C).


In summary, our findings show that temporal stability is significantly influenced by response diversity (balance), nutrient concentration, and temperature, with higher nutrient concentrations enhancing stability and higher temperatures reducing it. However, species richness was not a significant determinant of stability within the conditions of this study.




**Table 9**: Type II anova table of the model with balance, richness, nutrients, and temperature as predictors of stability.

```{r}
# produce publication ready anova table using gtsummary

# Get ANOVA table using car::Anova for Type II sum of squares
anova_table <- car::Anova(lm_full, type = "II")

# Convert to tidy format
anova_tidy <- broom::tidy(anova_table)

# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy %>%
  gt() %>%
  tab_header(title = "Type III ANOVA Table for Linear Model") %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(20),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )


```




## Interaction between temperature and nutrients

We may expect and interactive effect of the environmental variables on stability. We thus build a linear model with interaction between temperature and nutrients.
However, there is high collinearity between temperature and nutrients, which may affect the model results. 

<!-- ```{r model_check_int, fig.cap='model check 1.', fig.align="center", fig.height=9, fig.width=12, include=TRUE, echo=TRUE} -->
<!-- lm_full_int<-lm(data=complete_aggr,log10(stability)~log10(balance_f)+(richness)+nutrients*temperature) -->

<!-- # check model assumptions -->
<!-- check_model(lm_full_int) -->
<!-- ``` -->


So we transformed nutrients and temperature to numeric, and transformed temperature regimes in values = 1, 2, 3. Then, we centered the variables to avoid collinearity with the interaction term. 

```{r model_check_int2, fig.cap='model check 1.', fig.align="center", fig.height=9, fig.width=12, , include=TRUE, echo=TRUE}
# transform nutrients and temperature to numeric. For this the units need to be removed, and temperature regimes should be transformed in values = 1, 2, 3
complete_aggr_2<- complete_aggr %>%
  # Remove the units from the 'nutrients' and 'temperature' columns
  mutate(
    nutrients = as.numeric(gsub(" g/L", "", nutrients)),  # Convert nutrients to numeric
    temperature = gsub(" °C", "", temperature)            # Remove the unit but keep as character
  ) %>%
  # Convert temperature ranges to numeric codes using case_when
  mutate(
    temperature = case_when(
      temperature == "18-21" ~ 1,
      temperature == "22-25" ~ 2,
      temperature == "25-28" ~ 3,
      TRUE ~ NA_real_         # Handle unexpected values with NA
    )
  )


# Fit the linear model with interaction
lm_full_int<-lm(data=complete_aggr_2,log10(stability)~log10(balance_f)+scale(nutrients)*scale(temperature)+richness)

# check model assumptions
# check_model(lm_full_int)


```


**Table 10**: Linear model results for the effects of balance, richness, nutrients, and temperature on community stability. Estimates are presented with 95% confidence intervals and p-values. 
```{r}
# produce publication ready table using gtsummary::tbl_regression

# Generate the regression table with enhanced styling

gtsummary::tbl_regression(lm_full_int,
               add_estimate_to_reference_row = TRUE, # Adds reference values for categorical predictors
               add_pairwise_contrasts = TRUE) %>% 
  # Customize table elements
  gtsummary::modify_header(label = "**Predictor**", estimate = "**Estimate**", conf.int = "**95% CI**", p.value = "**p-value**") %>%
  gtsummary::modify_footnote(everything() ~ NA) %>% # Remove default footnotes for clean look
  gtsummary::modify_spanning_header(c("estimate",  "p.value") ~ "**Linear Regression Results**") %>% # Title
  gtsummary::bold_labels() %>%
  gtsummary::as_gt() 

```


The interpretation of the model's results does not change compared to the model without interaction. Indeed, the interaction term between temperature and nutrients was not significant, suggesting that the relationship between temperature and nutrients does not significantly affect stability. However, the estimate of balance, although still significant, is slightly lower than in the model without interaction. 

**Table 10**: Type I anova table of the model with interaction between temperature and nutrients as predictors of stability.

```{r}

# Get ANOVA table using car::Anova for Type III sum of squares
anova_table <- anova(lm_full_int)

# Convert to tidy format
anova_tidy <- broom::tidy(anova_table)

# Display the tidy ANOVA table using gt with formatted p-values and adjusted size
anova_tidy %>%
  gt() %>%
  tab_header(title = "Type I ANOVA Table for Linear Model") %>%
  cols_label(
    term = "Term",
    sumsq = "Sum of Squares",
    df = "DF",
    statistic = "F Statistic",
    p.value = "p-value"
  ) %>%
  fmt_number(
    columns = vars(p.value),
    decimals = 3
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(
      columns = vars(p.value),
      rows = p.value < 0.05
    )
  ) %>%
  tab_options(
    table.width = px(800),            # Adjust table width (e.g., 400px)
    table.font.size = px(16),        # Adjust font size (e.g., 12px)
    data_row.padding = px(10)         # Adjust row padding (e.g., 4px for more compact rows)
  )

```







# Asynchrony
Response diversity (aka balance) has been suggested as a mechanism that promotes temporal stability of community biomass by promoting species asynchrony.

We thus calculated the asynchrony index suggested by [Gross et al. 2014](https://www.journals.uchicago.edu/doi/epdf/10.1086/673915) to calculate the effect of asynchrony on temporal stability and to see how reponse diversity relate to asynchrony.
The index ranges between -1 and 1, with -1 indicating perfect asyncrony and 1 being perfectly synchronous, and 0 indicating random variation.


```{r echo=F, warning=FALSE, results='hide'}

#filter out completely extinct microcosms


async_df<-complete_ts%>%dplyr::mutate(rep_var=sub("_[^_]+$", "", sample_ID))


async_Gross <- async_df %>% group_by(composition,sample_ID) %>%  
  do(synchrony_Gross = synchrony(., "day", "predict_spec", 
                              "biomass", metric = "Gross"))
async_Gross<-dplyr::mutate(async_Gross,synchrony_Gross=synchrony_Gross%>%unlist())

async_Loroeau <- async_df %>% group_by(composition,sample_ID) %>%  
  do(synchrony_L = synchrony(., "day", "predict_spec", 
                              "biomass", metric = "Loreau"))
async_Loroeau<-dplyr::mutate(async_Loroeau,synchrony_Loreau=synchrony_L%>%unlist())

async_aggr<-full_join(async_Gross,complete_aggr,join_by(sample_ID,composition))

async_aggr<-full_join(async_aggr,async_Loroeau,join_by(sample_ID,composition))

async_aggr_f<-async_aggr%>%dplyr::filter(nutrients!="0.01 g/L")
async_aggr<-async_aggr%>%dplyr::mutate(rep_var=sub("_[^_]+$", "", sample_ID))

# calculate spearman correlation coefficient and p value between asynchrony and stability


# nice table with the correlation coefficient and p value of the correlation between asynchrony and stability
cor.test(async_aggr$synchrony_Gross,async_aggr$balance_f) %>% 
  broom::tidy() %>% 
  dplyr::select(estimate, p.value) %>% 
  kable() %>% 
  kable_styling(full_width = F)


```


### Plot stability vs. Asynchrony Gross
```{r async_plots, fig.align="center", fig.height=6, fig.width=12}
plot_asynch_CV_G<-ggplot(data=async_aggr,aes(x=-synchrony_Gross,y=log10(1/CV),color=nutrients))+
  geom_point(size = 3.5, alpha = 0.65)+
  geom_smooth(method="lm",show.legend=F, linewidth = 2)+
  theme_classic()+
  scale_y_continuous(
    breaks = log10(c(0.1,0.2, 0.4, 0.8, 1.6, 3.2)),
    labels = c("0.1","0.2"," 0.4", "0.8", "1.6", "3.2")
  ) +
   theme(axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
         axis.text = element_text(size = 20),      
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 25),legend.position="none") +
   ylab("Temporal stability\nlog(mean/s.d.)")+
  xlab("Asynchrony")+
  facet_wrap(~nutrients, labeller = as_labeller(function(x) paste0("nutrients = ", x)))+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)



plot_asynch_CV_G

```


**Figure 8**: Relationship between temporal stability and asynchrony (Gross) divided by nutrient level.


The Pearson's correlation between asynchrony and stability is significant (estimate = -0.23, p < 0.001).
```{r include=TRUE, echo=TRUE}
cor.test((-1*async_aggr$synchrony_Gross),async_aggr$stability)
```


### Plot Asynchrony Gross vs fundamental balance

```{r async,  fig.align="center", fig.height=6, fig.width=12}

plot_asynch_B_G<-ggplot(data=async_aggr,aes(x=log10(balance_f),y=-synchrony_Gross,color=nutrients))+
  geom_point(size = 3.5, alpha = 0.65)+
  geom_smooth(method="lm",show.legend=F, linewidth = 2)+
  theme_classic()+
   theme(axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
         axis.text = element_text(size = 20),      
        strip.background = element_rect(fill = "grey80", color = NA),  
    strip.text = element_text(size = 25),legend.position="none") +
   xlab(expression(log(balance)["fund"] )) +
  ylab("Asynchrony")+
  facet_wrap(~nutrients, labeller = as_labeller(function(x) paste0("nutrients = ", x)))+
  scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)



plot_asynch_B_G

```
**Figure 9**: Relationship between asynchrony (Gross) and fundamental balance divided by nutrient level.

The Pearson's correlation between asynchrony and balance is significant (estimate = 18, p = 0.003).
```{r include=TRUE, echo=TRUE}
cor.test((-1*async_aggr$synchrony_Gross),(async_aggr$balance_f))
```

<!-- ```{r fig.align="center", fig.height=12, fig.width=16} -->

<!-- plot_asynch_CV_G <- plot_asynch_CV_G + labs(tag = "(a)") -->
<!-- plot_asynch_B_G <- plot_asynch_B_G + labs(tag = "(b)") -->

<!-- fig3 <- plot_asynch_CV_G / plot_asynch_B_G -->
<!-- fig3 -->
<!-- ggsave("figures_ms/fig.3.png", plot = fig3, width = 16, height = 12, dpi = 600) -->
<!-- ``` -->





# Population stability

The relationship between community stability and the stability of the individual populations that make up the community is a key question in community ecology. Importantly, community stability can result from low population stability, if populations fluctuate asynchronously, or from high population stability, if populations do not fluctuate much.
Synthesis of the literature suggests diversity can have a positive or negantive effect on population stability [Campbell et al 2010](https://nsojournals.onlinelibrary.wiley.com/doi/full/10.1111/j.1600-0706.2010.18768.x) and (Xu et al 2021)[https://onlinelibrary.wiley.com/doi/full/10.1111/ele.13777].

Theoretical work has suggested that community stability is a product of two quantities: the (a)synchrony of population fluctuations, and an average species-level population stability that is weighted by relative abundance [Thibaut & Connolly 2013](https://onlinelibrary.wiley.com/doi/full/10.1111/ele.12019). 

Critically, a balance value close to zero can result from high response diversity, but also from high population stability (population biomass does not change largely over time).
We want to look now at whether our new metric of balance can capture these two stabilising mechanisms.

Thus, we first calculate species-level population stability weighted by relative abundance. 

```{r echo=FALSE, warning=FALSE, results='hide'}


pop_aggr<-complete_ts%>%group_by(sample_ID,predict_spec)%>%summarize(pop_CV=sd(biomass)/mean(biomass),mean_biom_contribution=mean(biom_contribution,na.rm=T), pop_V= sd(biomass))

# Lehman & Tilman (2000), THIBAUT & Connolli (2013), Gross et al. (2014)

pop_aggr<-pop_aggr%>%group_by(sample_ID)%>%summarize(pop_V=sum(pop_V),
                                                     w_pop_CV=mean(pop_CV),na.rm=T)

pop_aggr<-pop_aggr%>%group_by(sample_ID)%>%full_join(async_aggr,pop_aggr,by="sample_ID")


plot_pop_aggr_balance<-ggplot(data=pop_aggr, aes(y=log10(stability),x=log10(1/w_pop_CV)))+
  geom_point(size = 3.5, alpha = 0.65)+
  geom_smooth(method="lm", linewidth = 2)+
  theme_classic() 

plot_pop_aggr_balance


# Do plot pop_stability vs balance and compare with balance vs asynchrony

```


<!-- ```{r include=TRUE, echo=TRUE} -->
<!-- lm_pop<-lm(data=pop_aggr,log10(1/w_pop_CV)~log10(balance_f)+(richness)+nutrients+temperature) -->

<!-- # check model assumptions -->
<!--  check_model(lm_pop) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- summary(lm_pop) -->
<!-- car::Anova(lm_pop, type = "II") -->
<!-- <!-- ``` --> -->


<!--  ```{r} -->
<!--  plot_R_complete_pop<-ggplot(data=pop_aggr)+ -->
<!--    geom_boxplot(aes(y=log10(1/w_pop_CV),x=richness))+ -->
<!--    geom_jitter(aes(y=log10(1/w_pop_CV),x=richness)) -->



<!-- plot_R_complete<-ggplot(data=pop_aggr)+ -->
<!--    geom_boxplot(aes(y=log10(1/w_pop_CV),x=richness))+ -->
<!--   geom_jitter(aes(y=log10(1/w_pop_CV),x=richness)) -->

<!--  plot_R_complete<-ggplot(data=pop_aggr)+theme_bw(base_size = 25)+ -->
<!--    geom_quasirandom(data= pop_aggr,aes(y=log10(1/w_pop_CV), x=richness, group=richness, colour=as.factor(richness)), -->
<!--                                    dodge.width=2, size=4) + -->
<!--   xlab("Richness")+ -->
<!--   theme(legend.position = "none", -->
<!--         axis.title.y = element_blank())+   scale_color_viridis_d(option = "inferno", begin = 0.2, end = 0.8)+ -->
<!--    labs (tag = "(a)") -->
<!--  ``` -->


# SEM 


Finally, we use a structural equation model (SEM) to explore how stability is influenced by asynchrony, population stability, balance and, nutrient levels. 
In order to develop a hypothesis regarding the influence of stability, we have drawn on existing literature. This has enabled us to posit that stability is influenced by two key factors: asynchrony and population stability. In turn, these are influenced by balance and, in our particular case, by nutrient levels.


```{r}

sem_aggr3 <- pop_aggr %>%
  ungroup() %>%  # Ensure there is no grouping
  mutate(
    log_balance_f = log10(balance_f),
    stability = log10(1 / CV),
    richness = as.numeric(richness),
    temperature=temperature,
    asynchrony_Gross= (-synchrony_Gross),
    pop_stability= log10(1/w_pop_CV),
    pop_var = log10(pop_V)
    #Keep it as an ordered factor
  )

model1C <- '
  stability ~ asynchrony_Gross
  +pop_stability 
 
  asynchrony_Gross ~ log_balance_f + nutrients
  pop_stability~log_balance_f + nutrients  
'


# Fit the model

fit1C <- sem(model1C,estimator="MLM",meanstructure = TRUE,data = sem_aggr3%>%dplyr::filter(!is.na(asynchrony_Gross)))
#modificationindices(fit1C)

# Summarize the results
summary(fit1C, standardized = TRUE,rsquare=T, fit.measures = TRUE)

```

```{r SEM, fig.cap = 'SEM.', fig.align="center", fig.height=6, fig.width=8}
knitr::include_graphics(("SEM_3.png"))

```
**Model Fit Indices**
The model fit indices suggest that the model fits the data well.

*Chi-Square Test (User Model)*: The chi-square test statistic for the user model is χ 2 =1.626 (scaled = 1.465) with 3 degrees of freedom and a p-value of 0.653 (scaled = 0.690). This indicates a good fit, as the test is non-significant, suggesting no significant difference between the observed and model-implied covariance matrices.

*Comparative Fit Index (CFI)* and *Tucker-Lewis Index (TLI)*: Both CFI and TLI values are 1.000, indicating an excellent model fit. Values close to or above 0.95 are generally considered good.

*Root Mean Square Error of Approximation (RMSEA)*: The RMSEA is 0.000, with a 90% confidence interval ranging from 0 to 0.090 (scaled = 0.080). This indicates a very good fit, as RMSEA values below 0.05 are ideal, and values below 0.08 are acceptable. The p-values for the RMSEA hypothesis tests suggest strong support for a close fit (RMSEA <= 0.05) and little evidence for a poor fit (RMSEA >= 0.08).

*Standardized Root Mean Square Residual (SRMR)*: The SRMR value is 0.017, which is also within the acceptable range (values below 0.08 are generally considered good).
Overall, the fit indices suggest that the model is an excellent fit for the data.

**Regression Paths and Interpretation**

**Stability Regressions**

*Stability ~ Asynchrony_Gross (asynchrny_Grss)*: The standardized estimate for the effect of asynchrony on stability is 0.340 (p < 0.001), indicating a significant positive association. Higher asynchrony in species dynamics is associated with increased community stability.

*Stability ~ Population Stability (pop_stability)*: The standardized estimate is 0.977 (p < 0.001), showing a strong positive relationship. This suggests that community stability is highly dependent on the stability of individual populations within the community.

**Asynchrony_Gross Regressions**

*Asynchrony_Gross ~ Log10(Balance):* The standardized estimate is -0.176 (p = 0.013), indicating a significant negative effect. Higher balance leads to lower asynchrony, suggesting that as balance increases, species within the community fluctuate more synchronously.

*Asynchrony_Gross ~ Nutrients:* The standardized estimate is -0.469 (p < 0.001), showing a strong negative relationship. Higher nutrient levels appear to reduce asynchrony, possibly by causing similar responses across species.

**Population Stability Regressions**

*Population Stability ~ Log10(Balance)*: The standardized estimate is -0.296 (p < 0.001), indicating that higher balance is associated with lower population stability.

*Population Stability ~ Nutrients*: The standardized estimate is 0.635 (p < 0.001), showing that higher nutrient levels are associated with increased population stability, likely because nutrients enhance conditions that support stable population dynamics.

**Variances and R-Squared Values**
*R-Squared for Stability*: The model explains 90.4% of the variance in community stability, indicating strong predictive power.

*R-Squared for Asynchrony_Gross*: The model explains 21.9% of the variance in asynchrony, which is moderate.

*R-Squared for Population Stability*: The model explains 56.2% of the variance in population stability, showing that nutrients and balance are important but not the only factors influencing it.

*Summary Interpretation*
Model Fit: The model has an excellent fit, as indicated by the fit indices.
Stability: Community stability is strongly influenced by both population stability and asynchrony among species, with population stability being the stronger predictor.
Asynchrony and Balance: Asynchrony decreases with increasing balance and nutrients, suggesting that these factors promote more synchronized fluctuations among species.
Population Stability and Nutrients: Higher nutrient levels are associated with increased population stability, suggesting that nutrient availability supports stable population dynamics. Conversely, higher balance is associated with decreased population stability.



# When will asynchrony be more important than population stability?
```{r}
source("r/our_functions.r")
## Create the communities
num_spp <- c(2, 4, 8, 16)
max_minus_min <- round(seq(1, 7.5, length = 45),3)
mean <- round(seq(-5, 5, length = 49),3)
rd_vals <- function(num_spp, max_minus_min, mean) {
  seq(mean-max_minus_min/2, mean+max_minus_min/2, length = num_spp)
}
dd <- crossing(num_spp,
               max_minus_min,
               mean) %>%
  rowwise() %>%
  mutate(rd_vals = list(rd_vals(num_spp, max_minus_min, mean))) %>%
  unnest(cols = rd_vals)
```

```{r}
## calculate the diversity metrics
summary_stats <- dd %>%
  group_by(num_spp, max_minus_min, mean) %>%
  summarise(dissimilarity = resp_div(rd_vals,sign_sens = FALSE),
            divergence = resp_div(rd_vals,sign_sens = TRUE),
            balance = abs(sum(rd_vals)),
            magnitude = sum(abs(rd_vals))) %>%
  pivot_longer(names_to = "variable", values_to = "value", 4:5)


```


```{r}
# plot summary stats balance vs magnitude by num_spp
summary_stats %>%
  ggplot(aes(x = balance, y = magnitude)) +
  geom_point() +
  facet_wrap( ~ num_spp, scales = "free") +
  xlab("Balance") +
  ylab("Magnitude")

# create a new column called range with the range of magnitude values for each balance value
summary_stats <- summary_stats %>%
  group_by(num_spp, balance) %>%
  mutate(range = max(magnitude) - min(magnitude),
         mean = mean(magnitude))




library(scales)
# modify the above plot so that the gradient is present in each panel
summary_stats %>%
  group_by(num_spp) %>%
  mutate(magnitude_rescaled = rescale(balance / magnitude)) %>% # Rescale within each group
  ggplot(aes(x = balance, y = magnitude, color = magnitude_rescaled)) +
  geom_point() +
  facet_wrap(~num_spp, scales = "free") +
  xlab("Balance") +
  ylab("Magnitude") +
  scale_color_viridis_c(option = "plasma") +
  labs(color = "Community 1/Divergence") +
  theme_minimal()

```